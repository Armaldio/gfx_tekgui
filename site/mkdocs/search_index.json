{
    "docs": [
        {
            "location": "/", 
            "text": "English\n\n\nYou can read this manual in \nEnglish\n\n\nFran\u00e7ais\n\n\nMais vous pouvez aussi le lire en \nFran\u00e7ais", 
            "title": "Overview"
        }, 
        {
            "location": "/#english", 
            "text": "You can read this manual in  English", 
            "title": "English"
        }, 
        {
            "location": "/#francais", 
            "text": "Mais vous pouvez aussi le lire en  Fran\u00e7ais", 
            "title": "Fran\u00e7ais"
        }, 
        {
            "location": "/fr/basics/", 
            "text": "Bienvenue dans le tutoriel de la LibTekGui\n\n\nInstallation\n\n\nPremierement, cr\u00e9ez un dossier \nlib\n \u00e0 la racine de votre projet si il n'existe pas.\n\nPlacez-y ensuite le fichier \nlibtekgui.a\n.\n\n\nMaintenant il faut \u00e9diter votre Makefile\n\n\nAjoutez \nLIB_TEKGUI = -Llib -ltekgui\n dans vos variables et \n$(LIB_TEKGUI)\n dans votre ligne de compilation.\n\nSi vous n'utilisez pas de makefile, lancez \ncc/gcc\n avec \n-Llib -ltekgui\n en arguments.\n\n\nC'est tout !\n\n\nCode minimal\n\n\nVous avez besoin d'au moins un fichier \nmain.c\n un fichier de configuration : \nconfiguration.ini\n.\n\n\nFichier \nmain\n\n\nVoici un exemple basic de \nmain.c\n :\n\n\nint main()\n{\n  t_tekgui      *gui;\n\n   gui = tekgui_load(\nfull.ini\n);\n   gui-\npix = bunny_new_pixelarray(gui-\nsize.width, gui-\nsize.height);\n   tekgui_display(gui-\npix, gui);\n   tekgui_show(gui);\n   return(0);\n}\n\n\n\n\nt_tekgui\n est une structure qui contient toutes les donn\u00e9es de l'interface.\n\n\nPour d\u00e9finir cette variable, vous avez \u00e0 vote disposition la fonction \ntekgui_load\n. Vous devez lui passer un fichier de configuration en parametre.\n\n\ntekgui_display\n est utilis\u00e9e pour mettre toutes les donn\u00e9es de \ngui\n dans un \npixelarray\n \n1\n. Il y a d\u00e9ja un \npixelarray\n \n1\n dans la structure \nt_tekgui\n\n\nPour terminer, \ntekgui_show\n affiche la fenetre avec le contenu de \ngui\n et \ngui-\npix\n\n\nFichier de configuration\n\n\nVoici un exemple basique de fichier de configuration \nconfiguration.ini\n :\n\n\n[win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240\n\n\n\n\nCe fichier g\u00e9n\u00e9rera une fenetre vide de taille \n500\nx\n500\n, avec comme nom \nmy_name\n et avec une couleur de fond \n240\n,\n240\n,\n240\n (ce qui corresponds au gris clair similaire aux interfaces Windows).\n\n\nUne pr\u00e9visualisation du rendu :\n\n\n\n\nVous pouvez maintenant vous rendre a la seconde partie pour apprendre comment \nconstruire un fichier de configuration complet\n\n\n\n\n\n\n\n\n\n\nUn \npixelarray\n est un tableau d'entier non sign\u00e9s qui contient les caract\u00e9ristiques de chaque pixel (leur couleur).", 
            "title": "Bases"
        }, 
        {
            "location": "/fr/basics/#bienvenue-dans-le-tutoriel-de-la-libtekgui", 
            "text": "", 
            "title": "Bienvenue dans le tutoriel de la LibTekGui"
        }, 
        {
            "location": "/fr/basics/#installation", 
            "text": "Premierement, cr\u00e9ez un dossier  lib  \u00e0 la racine de votre projet si il n'existe pas. \nPlacez-y ensuite le fichier  libtekgui.a .  Maintenant il faut \u00e9diter votre Makefile  Ajoutez  LIB_TEKGUI = -Llib -ltekgui  dans vos variables et  $(LIB_TEKGUI)  dans votre ligne de compilation. \nSi vous n'utilisez pas de makefile, lancez  cc/gcc  avec  -Llib -ltekgui  en arguments.  C'est tout !", 
            "title": "Installation"
        }, 
        {
            "location": "/fr/basics/#code-minimal", 
            "text": "Vous avez besoin d'au moins un fichier  main.c  un fichier de configuration :  configuration.ini .", 
            "title": "Code minimal"
        }, 
        {
            "location": "/fr/basics/#fichier-main", 
            "text": "Voici un exemple basic de  main.c  :  int main()\n{\n  t_tekgui      *gui;\n\n   gui = tekgui_load( full.ini );\n   gui- pix = bunny_new_pixelarray(gui- size.width, gui- size.height);\n   tekgui_display(gui- pix, gui);\n   tekgui_show(gui);\n   return(0);\n}  t_tekgui  est une structure qui contient toutes les donn\u00e9es de l'interface.  Pour d\u00e9finir cette variable, vous avez \u00e0 vote disposition la fonction  tekgui_load . Vous devez lui passer un fichier de configuration en parametre.  tekgui_display  est utilis\u00e9e pour mettre toutes les donn\u00e9es de  gui  dans un  pixelarray   1 . Il y a d\u00e9ja un  pixelarray   1  dans la structure  t_tekgui  Pour terminer,  tekgui_show  affiche la fenetre avec le contenu de  gui  et  gui- pix", 
            "title": "Fichier main"
        }, 
        {
            "location": "/fr/basics/#fichier-de-configuration", 
            "text": "Voici un exemple basique de fichier de configuration  configuration.ini  :  [win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240  Ce fichier g\u00e9n\u00e9rera une fenetre vide de taille  500 x 500 , avec comme nom  my_name  et avec une couleur de fond  240 , 240 , 240  (ce qui corresponds au gris clair similaire aux interfaces Windows).  Une pr\u00e9visualisation du rendu :   Vous pouvez maintenant vous rendre a la seconde partie pour apprendre comment  construire un fichier de configuration complet      Un  pixelarray  est un tableau d'entier non sign\u00e9s qui contient les caract\u00e9ristiques de chaque pixel (leur couleur).", 
            "title": "Fichier de configuration"
        }, 
        {
            "location": "/fr/building_ini/", 
            "text": "Construire votre ini\n\n\nBases\n\n\nUn fichier ini de base est compos\u00e9 d'au minimum :\n\n\n[win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240\n\n\n\n\nMais, qu'est ce que cela veu dire ?\n\n\n[win]\n indique que nous sommes en train de travailler dans le \nscope\n \nwin\n qui fait r\u00e9f\u00e9rence \u00e0 la fen\u00eatre principale. Il peut y avoir autant de \n__scopes\n que vous voulez dans votre fichier ini.\n\n\nwidth\n, \nheight\n, \nname\n, \nbgcolor\n sont des \nfields\n. Les \nfields\n sont contenus dans les \nscope\n.\n\nLe fihier ini est bas\u00e9 sur un systeme de cl\u00e9=valeur. La cl\u00e9 est \nwidth\n et la valeur \n500\n.\n\n\nC'est aussi simple que \u00e7a !\n\n\nChamps support\u00e9s\n\n\nIl y a beaucoup de champs support\u00e9s dans cette librairie. Le fichier ini est concue pour \u00eatre simple a configurer.\n\n\nSi vous voulez, par exemple, ajouter un bouton, ajoutez juste un \nscope\n\navec toutes les cl\u00e9s dont un bouton a besoin. Ensuite, ajoutez dans le \nscope\n \nwin\n un champs \nbuttons\n et placez-y les \nscopes\n de votre bouton, s\u00e9par\u00e9s par une virgule.\n\nFa\u00eetes bien attention a construire correctememnt votre ini, sinon vous aurez des erreurs.\n\n\n[win]\nwidth=500\nheight=500\nname=my_win\nbgcolor=240,240,240\nbuttons=btn1,btn2\n\n[btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext=\nOK\n\nfontColor=0,0,0\ntextalign=center\nonclick=btn1_ok\n\n[btn2]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext=\nCancel\n\nfontColor=0,0,0\ntextalign=center\nonclick=btn2_cancel\n\n\n\n\nVousci le rendu :\n\n\n\n\nMaintenant que vous savez comment construire un ini de base, vous devriez lire la section des composants.\n\nElle liste tous les composants disponibles et leurs cl\u00e9/valeurs respectives\n\n\nVoir les composants", 
            "title": "Comment construire un ini"
        }, 
        {
            "location": "/fr/building_ini/#construire-votre-ini", 
            "text": "", 
            "title": "Construire votre ini"
        }, 
        {
            "location": "/fr/building_ini/#bases", 
            "text": "Un fichier ini de base est compos\u00e9 d'au minimum :  [win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240  Mais, qu'est ce que cela veu dire ?  [win]  indique que nous sommes en train de travailler dans le  scope   win  qui fait r\u00e9f\u00e9rence \u00e0 la fen\u00eatre principale. Il peut y avoir autant de  __scopes  que vous voulez dans votre fichier ini.  width ,  height ,  name ,  bgcolor  sont des  fields . Les  fields  sont contenus dans les  scope . \nLe fihier ini est bas\u00e9 sur un systeme de cl\u00e9=valeur. La cl\u00e9 est  width  et la valeur  500 .  C'est aussi simple que \u00e7a !", 
            "title": "Bases"
        }, 
        {
            "location": "/fr/building_ini/#champs-supportes", 
            "text": "Il y a beaucoup de champs support\u00e9s dans cette librairie. Le fichier ini est concue pour \u00eatre simple a configurer.  Si vous voulez, par exemple, ajouter un bouton, ajoutez juste un  scope \navec toutes les cl\u00e9s dont un bouton a besoin. Ensuite, ajoutez dans le  scope   win  un champs  buttons  et placez-y les  scopes  de votre bouton, s\u00e9par\u00e9s par une virgule. \nFa\u00eetes bien attention a construire correctememnt votre ini, sinon vous aurez des erreurs.  [win]\nwidth=500\nheight=500\nname=my_win\nbgcolor=240,240,240\nbuttons=btn1,btn2\n\n[btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext= OK \nfontColor=0,0,0\ntextalign=center\nonclick=btn1_ok\n\n[btn2]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext= Cancel \nfontColor=0,0,0\ntextalign=center\nonclick=btn2_cancel  Vousci le rendu :   Maintenant que vous savez comment construire un ini de base, vous devriez lire la section des composants. \nElle liste tous les composants disponibles et leurs cl\u00e9/valeurs respectives  Voir les composants", 
            "title": "Champs support\u00e9s"
        }, 
        {
            "location": "/fr/components/", 
            "text": "Type de donn\u00e9es\n\n\nCouleur\n\n\nUne couleur est d\u00e9finie par un ensemble de 3 valeurs, comprises entre 0 et 255, s\u00e9par\u00e9es par des virgules. \n ex: \n26,22,128\n \n La couleur est \n\n\nPosition\n\n\nUne position est d\u00e9finie par un ensemble de 2 valeurs, s\u00e9par\u00e9es par des virgules \n ex: \n50,100\n \n TCette position est relative \u00e0 la fen\u00eatre\n\n\nTaille\n\n\nUne taille est d\u00e9finie par un ensemble de 2 values, s\u00e9par\u00e9es par des virgules \n ex: \n16,16\n\n\nCha\u00eene de caractere\n\n\nUne chaine-de-caractere est une cha\u00eene de caracteres \n ex: \n\"Bonjour\"\n \n Une chaine-de-caractere est toujours entre guillements \" \"\n\n\nNom de fonction\n\n\nUn nom de fonction est une chaine de caractere qu correspond a une fonction pr\u00e9sente a l'intereieur de votre code \n ex: \ntekgui_load\n\n\nComposants\n\n\nFen\u00eatre\n\n\nDans votre \nscope\n \nwin\n\n\nwidth\n est un entier\n\n\nheight\n est un entier\n\n\nname\n est une \ncha\u00eene de caract\u00e8res\n\n\nBouton\n\n\n\n\nDans votre \nscope\n \nwin\n\n\nbuttons=btn1,btn2\n\n[btn1]\n...\n\n\n\n\nDans votre \nscope\n bouton :\n\n\nborderColor\n est une \ncouleur\n\n\ninnerColor\n est une \ncouleur\n\n\nborderSize\n est un entier (en pixels)\n\n\npos\n est un \nposition\n\n\nsize\n est une \ntaille\n\n\ntext\n est une \ncha\u00eene de caract\u00e8res\n\n\nfontColor\n est une \ncouleur\n\n\nonclick\n est un \nnom de fonction\n\n\nCase \u00e0 cocher\n\n\n\n\nDans votre \nscope\n \nwin\n\n\ncheckboxs=checkboxs1,checkboxs2\n\n[checkboxs1]\n...\n\n\n\n\nDans votre \nscope\n checkbox:\n\n\nfontSize\n est un entier (en pixels)\n\n\nfontColor\n  est une \ncouleur\n\n\npos\n est un \nposition\n\n\nsize\n est une \ntaille\n\n\ntext\n est une \ncha\u00eene de caract\u00e8res\n\n\noncheckstatechanged\n est un \nnom de fonction\n\n\nImage\n\n\nDans votre \nscope\n \nwin\n\n\nimages=img1\n\n[img1]\n...\n\n\n\n\nDans votre \nscope\n image :\n\n\npos\n est un \nposition\n\n\nsize\n est une \ntaille\n\n\nonclick\n est un \nnom de fonction\n\n\nborderSize\n est un entier\n\n\nborderColor\n est une \ncouleur\n\n\nsrc\n est une \ncha\u00eene de caract\u00e8res\n\n\nLabel\n\n\n\n\nDans votre \nscope\n \nwin\n\n\nlabels=label1,label2\n\n[label1]\n...\n\n\n\n\nDans votre scope \nscope\n label :\n\n\npos\n est un \nposition\n\n\nfontSize\n est un entier\n\n\nfontColor\n est une \ncouleur\n\n\ntext\n est une \ncha\u00eene de caract\u00e8res\n\n\nBarre de progression\n\n\n\n\n\n\nDans votre \nscope\n \nwin\n\n\nprogressbars=pgrsbar\n\n[pgrsbar]\n...\n\n\n\n\nDasn votre \nscope\n progressbar:\n\n\nborderColor\n est une \ncouleur\n\n\nborderSize\n est un entier\n\n\nbackColor\n est une \ncouleur\n\n\nbarColor\n est une \ncouleur\n\n\npos\n est un \nposition\n\n\nsize\n est un entier\n\n\nvalue\n est un entier\n\n\nmax, min\n est un entier\n\n\nBo\u00eete de texte\n\n\n\n\nDans votre \nscope\n \nwin\n\n\ntextboxs=tb\n\n[tb]\n...\n\n\n\n\nDans votre scope \nscope\n textbox :\n\n\nborderColor\n est une \ncouleur\n\n\nborderSize\n est un entier\n\n\nfontColor\n est une \ncouleur\n\n\nfontSize\n est un entier\n\n\ninnerColor\n est une \ncouleur\n\n\npos\n est un \nposition\n\n\nsize\n est un entier\n\n\nplaceholder\n est une \ncha\u00eene de caract\u00e8res\n\n\nplaceholderColor\n est une \ncouleur\n\n\nontextentered\n est un \nnom de fonction\n\n\nonclick\n est un \nnom de fonction", 
            "title": "Configuration des conmposants"
        }, 
        {
            "location": "/fr/components/#type-de-donnees", 
            "text": "", 
            "title": "Type de donn\u00e9es"
        }, 
        {
            "location": "/fr/components/#couleur", 
            "text": "Une couleur est d\u00e9finie par un ensemble de 3 valeurs, comprises entre 0 et 255, s\u00e9par\u00e9es par des virgules.   ex:  26,22,128    La couleur est", 
            "title": "Couleur"
        }, 
        {
            "location": "/fr/components/#position", 
            "text": "Une position est d\u00e9finie par un ensemble de 2 valeurs, s\u00e9par\u00e9es par des virgules   ex:  50,100    TCette position est relative \u00e0 la fen\u00eatre", 
            "title": "Position"
        }, 
        {
            "location": "/fr/components/#taille", 
            "text": "Une taille est d\u00e9finie par un ensemble de 2 values, s\u00e9par\u00e9es par des virgules   ex:  16,16", 
            "title": "Taille"
        }, 
        {
            "location": "/fr/components/#chaine-de-caractere", 
            "text": "Une chaine-de-caractere est une cha\u00eene de caracteres   ex:  \"Bonjour\"    Une chaine-de-caractere est toujours entre guillements \" \"", 
            "title": "Cha\u00eene de caractere"
        }, 
        {
            "location": "/fr/components/#nom-de-fonction", 
            "text": "Un nom de fonction est une chaine de caractere qu correspond a une fonction pr\u00e9sente a l'intereieur de votre code   ex:  tekgui_load", 
            "title": "Nom de fonction"
        }, 
        {
            "location": "/fr/components/#composants", 
            "text": "", 
            "title": "Composants"
        }, 
        {
            "location": "/fr/components/#fenetre", 
            "text": "Dans votre  scope   win  width  est un entier  height  est un entier  name  est une  cha\u00eene de caract\u00e8res", 
            "title": "Fen\u00eatre"
        }, 
        {
            "location": "/fr/components/#bouton", 
            "text": "Dans votre  scope   win  buttons=btn1,btn2\n\n[btn1]\n...  Dans votre  scope  bouton :  borderColor  est une  couleur  innerColor  est une  couleur  borderSize  est un entier (en pixels)  pos  est un  position  size  est une  taille  text  est une  cha\u00eene de caract\u00e8res  fontColor  est une  couleur  onclick  est un  nom de fonction", 
            "title": "Bouton"
        }, 
        {
            "location": "/fr/components/#case-a-cocher", 
            "text": "Dans votre  scope   win  checkboxs=checkboxs1,checkboxs2\n\n[checkboxs1]\n...  Dans votre  scope  checkbox:  fontSize  est un entier (en pixels)  fontColor   est une  couleur  pos  est un  position  size  est une  taille  text  est une  cha\u00eene de caract\u00e8res  oncheckstatechanged  est un  nom de fonction", 
            "title": "Case \u00e0 cocher"
        }, 
        {
            "location": "/fr/components/#image", 
            "text": "Dans votre  scope   win  images=img1\n\n[img1]\n...  Dans votre  scope  image :  pos  est un  position  size  est une  taille  onclick  est un  nom de fonction  borderSize  est un entier  borderColor  est une  couleur  src  est une  cha\u00eene de caract\u00e8res", 
            "title": "Image"
        }, 
        {
            "location": "/fr/components/#label", 
            "text": "Dans votre  scope   win  labels=label1,label2\n\n[label1]\n...  Dans votre scope  scope  label :  pos  est un  position  fontSize  est un entier  fontColor  est une  couleur  text  est une  cha\u00eene de caract\u00e8res", 
            "title": "Label"
        }, 
        {
            "location": "/fr/components/#barre-de-progression", 
            "text": "Dans votre  scope   win  progressbars=pgrsbar\n\n[pgrsbar]\n...  Dasn votre  scope  progressbar:  borderColor  est une  couleur  borderSize  est un entier  backColor  est une  couleur  barColor  est une  couleur  pos  est un  position  size  est un entier  value  est un entier  max, min  est un entier", 
            "title": "Barre de progression"
        }, 
        {
            "location": "/fr/components/#boite-de-texte", 
            "text": "Dans votre  scope   win  textboxs=tb\n\n[tb]\n...  Dans votre scope  scope  textbox :  borderColor  est une  couleur  borderSize  est un entier  fontColor  est une  couleur  fontSize  est un entier  innerColor  est une  couleur  pos  est un  position  size  est un entier  placeholder  est une  cha\u00eene de caract\u00e8res  placeholderColor  est une  couleur  ontextentered  est un  nom de fonction  onclick  est un  nom de fonction", 
            "title": "Bo\u00eete de texte"
        }, 
        {
            "location": "/en/functions/", 
            "text": "Interactions\n\n\nNow that you know how to design your basic interface, what about interacting with it ?\n\n\nInteracting with components\n\n\nThere are several function to make your life easier\n\nAll the function are based on the name of your component.\n\nto refresh a bit your memeory, the name of your component is his \nscope\n\n\nOk, say we have a button like this :\n\n\n[btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=1\npos=10,10\nsize=150,50\ntext=\nOK\n\nfontColor=0,0,0\nonclick=click\n\n\n\n\nAnd i want to grab the current state of the button loaded in memory, what should I do ?\n\nI just have the function : \nbutton_get\n\n\nHere is how to use it :\n\n\nt_button  *button;\n\nbutton = button_get(gui, \nbtn1\n)\nbutton-\ntext = \nHello\n;\n\n\n\n\nIf you don't want to define a variable, to reduce code size, you can also do it this way :\n\n\nbutton_get(gui, \nbtn1\n)-\ntext = \nBonjour\n;\n\n\n\n\nNow you can interact with your button and access all it's components\n\nIt also works for all the components\n\nI invite you to read the \nfunction list\n to know all the capabilities.\n\n\nAdding keybindings\n\n\nYou can define your own keybindings with a simple function :\n\n\ntekgui_addkeytrigger(gui, BKS_J, \nclick\n, GO_DOWN);\n\n\n\n\nWhere \ngui\n is the \nt_tekgui\n component\n\n\nBKS_J\n is the key (see the \nkeylist\n)\n\n\n\"click\"\n is the function name that will be called\n\n\nGO_DOWN\n is the state of the key (see the \nstate list\n)\n\n\nAdding new components\n\n\nTODO\n\n\nUser utility\n\n\nIt's cool to add custom triggers but how can I get custom values ?\n\nThe answer is \nuserdata\n !\n\nin fact, inside the \nt_tekgui\n structure there is a variable called \nuserdata\n of type \nvoid *\n\n\nYou don't know how to use it ?\n\nIt's easy :\n\n\n\n\ndefine a custom structure\n\n\n\n\ntypedef struct  s_myuserstructure\n{\n    char        *text;\n}                t_myuserstructure;\n\n\n\n\n\n\nPut it in your main\n\n\n\n\n//Define structure\nt_myuserstructure   st;\n\n//Set data inside structure\nst.text = \nBonjour\n;\n\n//Set userdata equal to your datas\ngui-\nuserdata = \nst;\n\n\n\n\n\n\nEvery trigger receive the \nt_tekgui\n structure\n\nGrab your datas like this :\n\n\n\n\n//Function triggered when a button is clicked\nvoid            click(void *data)\n{\n  //Define t_tekgui and t_myuserstructure\n  t_tekgui      *gui;\n  t_myuserstructure *st;\n\n  //get gui structure from data\n  gui = (t_tekgui *) data;\n\n  //get your structure from userdata\n  st = (t_myuserstructure *) gui-\nuserdata;\n\n  //Now feel free to use you data as want :)\n  my_putstr(st-\ntext);\n}", 
            "title": "Fonctions"
        }, 
        {
            "location": "/en/functions/#interactions", 
            "text": "Now that you know how to design your basic interface, what about interacting with it ?", 
            "title": "Interactions"
        }, 
        {
            "location": "/en/functions/#interacting-with-components", 
            "text": "There are several function to make your life easier \nAll the function are based on the name of your component. \nto refresh a bit your memeory, the name of your component is his  scope  Ok, say we have a button like this :  [btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=1\npos=10,10\nsize=150,50\ntext= OK \nfontColor=0,0,0\nonclick=click  And i want to grab the current state of the button loaded in memory, what should I do ? \nI just have the function :  button_get  Here is how to use it :  t_button  *button;\n\nbutton = button_get(gui,  btn1 )\nbutton- text =  Hello ;  If you don't want to define a variable, to reduce code size, you can also do it this way :  button_get(gui,  btn1 )- text =  Bonjour ;  Now you can interact with your button and access all it's components \nIt also works for all the components \nI invite you to read the  function list  to know all the capabilities.", 
            "title": "Interacting with components"
        }, 
        {
            "location": "/en/functions/#adding-keybindings", 
            "text": "You can define your own keybindings with a simple function :  tekgui_addkeytrigger(gui, BKS_J,  click , GO_DOWN);  Where  gui  is the  t_tekgui  component  BKS_J  is the key (see the  keylist )  \"click\"  is the function name that will be called  GO_DOWN  is the state of the key (see the  state list )", 
            "title": "Adding keybindings"
        }, 
        {
            "location": "/en/functions/#adding-new-components", 
            "text": "TODO", 
            "title": "Adding new components"
        }, 
        {
            "location": "/en/functions/#user-utility", 
            "text": "It's cool to add custom triggers but how can I get custom values ? \nThe answer is  userdata  ! \nin fact, inside the  t_tekgui  structure there is a variable called  userdata  of type  void *  You don't know how to use it ? \nIt's easy :   define a custom structure   typedef struct  s_myuserstructure\n{\n    char        *text;\n}                t_myuserstructure;   Put it in your main   //Define structure\nt_myuserstructure   st;\n\n//Set data inside structure\nst.text =  Bonjour ;\n\n//Set userdata equal to your datas\ngui- userdata =  st;   Every trigger receive the  t_tekgui  structure \nGrab your datas like this :   //Function triggered when a button is clicked\nvoid            click(void *data)\n{\n  //Define t_tekgui and t_myuserstructure\n  t_tekgui      *gui;\n  t_myuserstructure *st;\n\n  //get gui structure from data\n  gui = (t_tekgui *) data;\n\n  //get your structure from userdata\n  st = (t_myuserstructure *) gui- userdata;\n\n  //Now feel free to use you data as want :)\n  my_putstr(st- text);\n}", 
            "title": "User utility"
        }, 
        {
            "location": "/en/function_list/", 
            "text": "Functions\n\n\nt_tekgui    *tekgui_load(const char *file);\n\n\n\n\nLoad a configuration file \nfile\n inside a \nt_tekgui *\n\n\n\n\nvoid        tekgui_unload(t_tekgui *tekgui);\n\n\n\n\nUnload \ntekgui\n from the memory\n\n\n\n\nvoid        tekgui_display(t_bunny_pixelarray   *pix,\n                           t_tekgui             *gui);\n\n\n\n\nPut the graphical representation of \ngui\n inside \npix\n\n\n\n\nvoid        fill_color(t_bunny_pixelarray   *pixelarray,\n                        unsigned int        color);\n\n\n\n\nFill completely \npixelarray\n wiht the color \ncolor\n\n\n\n\nvoid            set_max_heap_size(size_t);\n\n\n\n\nSet the max ram for the program\n\n\n\n\nvoid            tekpixel(t_bunny_pixelarray *a,\n                 t_bunny_position   *p,\n                 t_color        *c);\n\n\n\n\nSet the color of a pixel at the position \np\n, of color \nc\n and inside \na\n\n\n\n\nt_bunny_position    new_bunny_position(int x, int y);\n\n\n\n\nCreate a \nt_bunny_position\n from \nx\n and \ny\n\n\n\n\nt_size          new_size(int w, int h);\n\n\n\n\nCreate a \nt_size\n from  width \nw\n and height \nh\n\n\n\n\nvoid            tekline(t_bunny_pixelarray  *pix,\n                t_bunny_position    *pos,\n                t_color         *color);\n\n\n\n\nDraw a line inside \npix\n from \npos[0]\n to \npos[1]\n of color \ncolor\n\n\n\n\nint         tekgui_putstring(t_text         text,\n                     t_bunny_pixelarray *pix,\n                     t_bunny_pixelarray *font);\n\n\n\n\nPut a string from a \nt_text\n inside \npix\n with the font \nfont\n\n\n\n\nunsigned int        tekgetpixel(t_bunny_pixelarray  *a,\n                    t_bunny_position    *p);\n\n\n\n\nreturn in an \nunsigned int\n the pixel color at \np\n inside \na\n\n\n\n\nt_color         new_color(int r, int g, int b, int a);\n\n\n\n\nCreate a \nt_color\n from \nr\n, \ng\n, \nb\n and \na\n component\n\n\n\n\nt_color         load_ini_color(t_bunny_ini *ini,\n                       char *field,\n                       char *name);\n\n\n\n\nload a \nt_color\n from \nini\n at \nfield\n-\nname\n\n\n\n\nvoid            *tekfunction(const char *funcname);\n\n\n\n\nReturn a function pointer from a \nchar *\n name\n\n\n\n\nint         is_hover(t_bunny_position   *from_pos,\n                 t_bunny_position   *pos,\n                 t_size         *size);\n\n\n\n\nDetermine if the position \nfrom_pos\n is inside the rectangle \npos-size\n\n\n\n\nint         display_button(t_bunny_pixelarray   *pix,\n                       t_button         *button,\n                       t_bunny_pixelarray   *font);\n\n\n\n\nUpdate the graphics of \nbutton\n inside \npix\n with the font \nfont\n\n\n\n\nt_size          load_ini_size(t_bunny_ini *ini, char *scope);\n\n\n\n\nload a \nt_size\n from a \nscope\n inside \nini\n\n\n\n\nt_bunny_position    load_ini_position(t_bunny_ini *ini, char *scope);\n\n\n\n\n\nLoad a  \nt_bunny_position\n from \nscope\n inside \nini\n\n\n\n\nint         display_textbox(t_bunny_pixelarray  *pix,\n                    t_textbox       *textbox,\n                    t_bunny_pixelarray  *font);\n\n\n\n\nUpdate the graphics of a \ntextbox\n inside \npix\n wiht the \nfont\n\n\n\n\nvoid            check_box(t_tekgui *gui, t_checkbox *checkbox);\n\n\n\n\nForce checking \ncheckbox\n\n\n\n\nvoid            uncheck_box(t_tekgui *gui, t_checkbox *checkbox);\n\n\n\n\nForce unchecking \ncheckbox\n\n\n\n\nint         display_checkbox(t_bunny_pixelarray *pix,\n                     t_checkbox     *checkbox,\n                     t_bunny_pixelarray *font,\n                     t_bunny_pixelarray **png_checkbox);\n\n\n\n\nupdate the graphics of \ncheckbox\n inside \npix\n, with \nfont\n and \npng_checkbox\n graphics\n\n\n\n\nvoid            tekgui_show(t_tekgui        *gui);\n\n\n\n\nOpen a window a show the \ngui\n\n\n\n\nt_bunny_pixelarray  *stretch(t_bunny_pixelarray *oldpixel,\n                 int            newx,\n                 int            newy);\n\n\n\n\nStretch an an image inside \noldpixel\n to be resize to \nnewx, newy\n\n\n\n\nt_progressbar       *progressbar_get(t_tekgui *gui, char *name);\n\n\n\n\nGet a progressbar by its \nname\n\n\n\n\nint         progressbar_setprogress(t_tekgui        *gui,\n                        t_progressbar       *progressbar,\n                        int         progress);\n\n\n\n\nSet the \nprogressbar\n progress to \nprogress\n\n\n\n\nint         progressbar_getprogress(t_progressbar *progressbar);\n\n\n\n\nget the current progress from a \nprogressbar\n\n\n\n\nint         display_prgrsbar(t_bunny_pixelarray *pix,\n                     t_progressbar      *prgrsbar);\n\n\n\n\nForce update graphic of \nprgrsbar inside\npix`\n\n\n\n\nt_button        *button_get(t_tekgui *gui, char *name);\n\n\n\n\nGet a \nt_button\n from its \nname\n\n\n\n\nint         button_settext(t_tekgui     *gui,\n                       t_button     *button,\n                       char     *text);\n\n\n\n\nSet the \ntext\n of a \nbutton\n\n\n\n\nchar            *button_gettext(t_button *button);\n\n\n\n\nGet the text of a \nbutton\n\n\n\n\nchar            *checkbox_gettext(t_checkbox *checkbox);\n\n\n\n\nGet the text of a \nt_checkbox\n\n\n\n\nt_checkbox      *checkbox_get(t_tekgui *gui, char *name);\n\n\n\n\nGet a \nt_checkbox\n from its name\n\n\n\n\nint         checkbox_settext(t_tekgui   *gui,\n                     t_checkbox *checkbox,\n                     char       *text);\n\n\n\n\nSet the \ntext\n  of a \ncheckbox\n\n\n\n\nt_image         *image_get(t_tekgui *gui, char *name);\n\n\n\n\nRetrieve a \nt_image\n from a \nname\n\n\n\n\nchar            *image_getsrc(t_image *image);\n\n\n\n\nGet the image \nsrc\n\n\n\n\nint         image_setsrc(t_tekgui   *gui,\n                     t_image    *image,\n                     char   *src);\n\n\n\n\nSet the \nimage\n \nsrc\n\n\n\n\nint         display_label(t_bunny_pixelarray    *pix,\n                      t_label           *label,\n                      t_bunny_pixelarray    *font);\n\n\n\n\nForce update graphics of a \nt_label\n\n\n\n\nt_textbox       *textbox_get(t_tekgui *gui, char *name);\n\n\n\n\nretrieve \nt_textbox\n from its \nname\n\n\n\n\nchar            *textbox_gettext(t_textbox *textbox);\n\n\n\n\nGet text of a \nt_textbox\n\n\n\n\nint         textbox_settext(t_tekgui    *gui,\n                    t_textbox   *textbox,\n                    char        *text);\n\n\n\n\nSet the text of a \nt_textbox\n\n\n\n\nint         display_image(t_bunny_pixelarray    *pix,\n                      t_image           *image,\n                      int           mode);\n\n\n\n\nForce update the graphic of a \nt_image\n\n\n\n\nchar            *getfield_safe(t_bunny_ini *ini,\n                       char *scope,\n                       char *field,\n                       int index);\n\n\n\n\nGet a field from a \nini\n with error management\n\n\nMacros\n\n\nCheckbox\n\n\nYou can check if the state of a checkbox is equal to \nCHECKED\n \nUNCHECKED\n\n\nImage\n\n\nThere are different size mode for images :\n\n\nSTRETCHMODE_FILL\n : The image fille the \nsize\n in any way\n\n\nSTRETCHMODE_NONE\n : The image is loaded normaly. If the \nsize\n is bigger than the image, it is sticked at the top-left. If the \nsize\n is smaller, the image is cropped\n\n\nSTRETCHMODE_CENTER\n : The image is loaded normaly. If the \nsize\n is bigger than the image, it is sticked at the center. If the \nsize\n is smaller, the image is cropped\n\n\nStructures\n\n\nt_size\n\n\nint     width;\nint     height;\n\n\n\n\nwidth\n : \ninteger\n : the width of the size\n\n\nheight\n : \ninteger\n : the height of the size\n\n\nt_text\n\n\nchar                *text;\nint                 size;\nt_bunny_position    position;\nt_color             color;\nt_bunny_pixelarray  *pix;\n\n\n\n\nchar *\n \ntext\n : the text that will be printed\n\n\nt_size\n \nsize\n : the size of the component\n\n\nt_bunny_position\n \nposition\n : the position of the component\n\n\nt_color\n \ncolor\n : the color of the text\n\n\nt_bunny_pixel_array *\n \npix\n : the pixelarray where the text will be dislpayed\n\n\nt_button\n\n\nchar            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;\n\n\n\n\nchar *\n \nname\n : the name of the button\n\n\nt_bunny_position\n \npos\n : The position of the button\n\n\nt_size\n \nsize\n : The size of the button\n\n\nt_color\n \nborderColor\n : The color of the border of the button\n\n\ninteger\n \nborderSize\n : The size of the button's border (in pixels)\n\n\nt_color\n \ninnerColor\n : The button's inner color\n\n\nchar *\n \ntext\n : The text of the button\n\n\ninteger\n \nfontSize\n : the font size of the button's text\n\n\nt_color\n \nfontColor\n : The color of the button's text\n\n\nptrfct\n \nonclick\n : The function called when the \nonclick\n event occurs\n\n\nptrfct\n \nonhover\n : The function called when the \nonhover\n event occurs\n\n\nt_label\n\n\nchar            *name;\nchar            *text;\nt_color     color;\nint         size;\nt_bunny_position    pos;\n\n\n\n\nchar *\n     \nname\n : The name of the label\n\n\nchar *\n     \ntext\n : The text of the label\n\n\nt_color\n     \ncolor\n : The text color of the label\n\n\nint\n         \nsize\n : The size of the label\n\n\nt_bunny_position\n    \npos\n : The position of he label\n\n\nt_checkbox\n\n\nchar            *name;\nint         state;\nt_size      size;\nt_color     backcolor;\nptrfct      oncheckstatechanged;\nt_label     *label;\n\n\n\n\nchar *\n         \nname\n : The name of th checkbox\n\n\nint\n         \nstate\n : The current state of the checkbox\n\n\nt_size\n      \nsize\n : The size of the checkbox\n\n\nptrfct\n      \noncheckstatechanged\n : The function called when the \noncheckstatechanged\n event occurs\n\n\nt_label *\n      \nlabel\n : The label linked to the checkbox\n\n\nt_progressbar\n\n\nchar            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     backColor;\nt_color     barColor;\nint         value;\nint         max;\nint         min;\nt_label     attached_text;\n\n\n\n\nchar *\n         \nname\n\n\n\n\nThe name of the progressbar\n\n\n\n\nt_bunny_position\n    \npos\n\n\n\n\nThe position of the progressbar\n\n\n\n\nt_size\n      \nsize\n\n\n\n\nThe size of the progressbar\n\n\n\n\nt_color\n     \nborderColor\n\n\n\n\nThe color of the progressbar border\n\n\n\n\nint\n         \nborderSize\n\n\n\n\nThe size of the progressbar's border\n\n\n\n\nt_color\n     \nbackColor\n\n\n\n\nThe back color of the progressbar\n\n\n\n\nt_color\n     \nbarColor\n\n\n\n\nThe color of the progressbar's bar\n\n\n\n\nint\n         \nvalue\n\n\n\n\nThe current value of the progressbar\n\n\n\n\nint\n         \nmax\n\n\n\n\nThe max value of the progressbar\n\n\n\n\nint\n         \nmin\n\n\n\n\nThe minimum value of the progressbar\n\n\n\n\nt_label\n     \nattached_text\n\n\n\n\nThe text attached to the progressbar\n\n\n\n\nt_textbox\n\n\nchar            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nchar            *placeholder;\nt_color     placeholder_color;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;\nptrfct      ontextchanged;\nint         waiting_for_text;\n\n\n\n\nchar *\n         \nname\n : The name\n\n\nt_bunny_position\n    \npos\n : The position\n\n\nt_size\n      \nsize\n : The size\n\n\nt_color\n     \nborderColor\n : The border color\n\n\nint\n         \nborderSize\n : The border size\n\n\nt_color\n     \ninnerColor\n : The inner coloor\n\n\nchar *\n         \ntext\n : The predefined text\n\n\nchar *\n         \nplaceholder\n : the placeholder (Appear if no text is typed)\n\n\nt_color\n     \nplaceholder_color\n : The placeholder font color\n\n\nint\n         \nfontSize\n : The text font size\n\n\nt_color\n     \nfontColor\n : The text font color\n\n\nptrfct\n      \nonclick\n : The function called when the \nonclick\n event occurs\n\n\nptrfct\n      \nonhover\n : The function called when the \nonhover\n event occurs\n\n\nptrfct\n      \nontextchanged\n : The function called when the \nontextchanged\n event occurs\n\n\nint\n         \nwaiting_for_text\n : Set to 1 if the textbox is waiting text \ni.e.\n the textbox is selected\n\n\nt_image\n\n\nSee the \nImage macros\n\n\nchar            *name;\nint         borderSize;\nt_color     borderColor;\nchar            *src;\nt_size      size;\nt_bunny_position    pos;\nptrfct      onclick;\n\n\n\n\nchar *\n         \nname\n : The name\n\n\nint\n         \nborderSize\n : the size of the border\n\n\nt_color\n     \nborderColor\n : The color of the border\n\n\nchar *\n         \nsrc\n : The path to the image source\n\n\nt_size\n      \nsize\n : The size of the frame where the image will be displayed\n\n\nt_bunny_position\n    \npos\n : The position\n\n\nptrfct\n      \nonclick\n : The function called when the \nonclick\n event occurs\n\n\nt_tekgui\n\n\nstruct s_tekgui *child_win;\nint         child_win_nbr;\nt_button        *buttons;\nint         buttons_nbr;\nt_checkbox      *checkboxs;\nint         checkboxs_nbr;\nt_progressbar       *progressbars;\nint         progressbars_nbr;\nt_label     *labels;\nint         labels_nbr;\nt_textbox       *textboxs;\nint         textboxs_nbr;\nt_image     *images;\nint         images_nbr;\nt_bunny_ini     *config;\nt_size      size;\nt_bunny_window  *win;\nchar            *name;\nt_bunny_pixelarray  *pix;\nt_color     bgcolor;\nt_bunny_pixelarray  *font;\nt_bunny_pixelarray  **png_checkbox;\nt_callback_list callback;\ndouble      progress;\nvoid            *userdata;\n\n\n\n\nstruct s_tekgui   *\nchild_win\n : A pointer to windows child of the main window\n\n\nint\n \nchild_win_nbr\n : The number of child windows\n\n\nt_button *\nbuttons\n : A pointer to the buttons\n\n\nint\n \nbuttons_nbr\n : The number of buttons\n\n\nt_checkbox *\n \ncheckboxs\n : A pointer to the checkboxs\n\n\nint\n \ncheckboxs_nbr\n : The number of checkboxs\n\n\nt_progressbar *\n \nprogressbars\n : A pointer to the progressbars\n\n\nint\n \nprogressbars_nbr\n : The number of progressbars\n\n\nt_label *\n \nlabels\n : A pointer to the labels\n\n\nint\n \nlabels_nbr\n : The number of labels\n\n\nt_textbox *\n \ntextboxs\n : A pointer to the textboxs\n\n\nint\n \ntextboxs_nbr\n : The number of textboxs\n\n\nt_image *\n \nimages\n : A pointer to the images\n\n\nint\n \nimages_nbr\n : The number of images\n\n\nt_bunny_ini *\n \nconfig\n : The current config file\n\n\nt_size\n \nsize\n : The window original size\n\n\nt_bunny_window *\n \nwin\n : The \nt_buny_window\n component (for sharing)\n\n\nchar *\n \nname\n : The window name\n\n\nt_bunny_pixelarray *\n \npix\n : The render \npixelarray\n\n\nt_color\n \nbgcolor\n : The background color\n\n\nt_bunny_pixelarray *\n \nfont\n : The font file\n\n\nt_bunny_pixelarray **\n \npng_checkbox\n : The checkbox image ressource\n\n\nvoid *\n \nuserdata\n : The variable where the user can put his datas\n\n\nTips and tricks\n\n\nYou can define colors in several ways\n\nIf you have an \nunsigned int\n : 0xff0000\n\nBut you need a \nt_color\n, you can simply do this :\n\n\nt_color color;\nunsigned int c;\n\nc = 0xff0000;\ncolor.full = c;\n\n\n\n\nIt will convert your \nunsigned int\n to a \nt_color\n\nIn reverse you can do this too\n\n\nt_color color;\nunsigned int c;\n\ncolor.argb[0] = 255;\ncolor.argb[1] = 0;\ncolor.argb[2] = 0;\nc = color.full;", 
            "title": "Liste des fonction"
        }, 
        {
            "location": "/en/function_list/#functions", 
            "text": "t_tekgui    *tekgui_load(const char *file);  Load a configuration file  file  inside a  t_tekgui *   void        tekgui_unload(t_tekgui *tekgui);  Unload  tekgui  from the memory   void        tekgui_display(t_bunny_pixelarray   *pix,\n                           t_tekgui             *gui);  Put the graphical representation of  gui  inside  pix   void        fill_color(t_bunny_pixelarray   *pixelarray,\n                        unsigned int        color);  Fill completely  pixelarray  wiht the color  color   void            set_max_heap_size(size_t);  Set the max ram for the program   void            tekpixel(t_bunny_pixelarray *a,\n                 t_bunny_position   *p,\n                 t_color        *c);  Set the color of a pixel at the position  p , of color  c  and inside  a   t_bunny_position    new_bunny_position(int x, int y);  Create a  t_bunny_position  from  x  and  y   t_size          new_size(int w, int h);  Create a  t_size  from  width  w  and height  h   void            tekline(t_bunny_pixelarray  *pix,\n                t_bunny_position    *pos,\n                t_color         *color);  Draw a line inside  pix  from  pos[0]  to  pos[1]  of color  color   int         tekgui_putstring(t_text         text,\n                     t_bunny_pixelarray *pix,\n                     t_bunny_pixelarray *font);  Put a string from a  t_text  inside  pix  with the font  font   unsigned int        tekgetpixel(t_bunny_pixelarray  *a,\n                    t_bunny_position    *p);  return in an  unsigned int  the pixel color at  p  inside  a   t_color         new_color(int r, int g, int b, int a);  Create a  t_color  from  r ,  g ,  b  and  a  component   t_color         load_ini_color(t_bunny_ini *ini,\n                       char *field,\n                       char *name);  load a  t_color  from  ini  at  field - name   void            *tekfunction(const char *funcname);  Return a function pointer from a  char *  name   int         is_hover(t_bunny_position   *from_pos,\n                 t_bunny_position   *pos,\n                 t_size         *size);  Determine if the position  from_pos  is inside the rectangle  pos-size   int         display_button(t_bunny_pixelarray   *pix,\n                       t_button         *button,\n                       t_bunny_pixelarray   *font);  Update the graphics of  button  inside  pix  with the font  font   t_size          load_ini_size(t_bunny_ini *ini, char *scope);  load a  t_size  from a  scope  inside  ini   t_bunny_position    load_ini_position(t_bunny_ini *ini, char *scope);  Load a   t_bunny_position  from  scope  inside  ini   int         display_textbox(t_bunny_pixelarray  *pix,\n                    t_textbox       *textbox,\n                    t_bunny_pixelarray  *font);  Update the graphics of a  textbox  inside  pix  wiht the  font   void            check_box(t_tekgui *gui, t_checkbox *checkbox);  Force checking  checkbox   void            uncheck_box(t_tekgui *gui, t_checkbox *checkbox);  Force unchecking  checkbox   int         display_checkbox(t_bunny_pixelarray *pix,\n                     t_checkbox     *checkbox,\n                     t_bunny_pixelarray *font,\n                     t_bunny_pixelarray **png_checkbox);  update the graphics of  checkbox  inside  pix , with  font  and  png_checkbox  graphics   void            tekgui_show(t_tekgui        *gui);  Open a window a show the  gui   t_bunny_pixelarray  *stretch(t_bunny_pixelarray *oldpixel,\n                 int            newx,\n                 int            newy);  Stretch an an image inside  oldpixel  to be resize to  newx, newy   t_progressbar       *progressbar_get(t_tekgui *gui, char *name);  Get a progressbar by its  name   int         progressbar_setprogress(t_tekgui        *gui,\n                        t_progressbar       *progressbar,\n                        int         progress);  Set the  progressbar  progress to  progress   int         progressbar_getprogress(t_progressbar *progressbar);  get the current progress from a  progressbar   int         display_prgrsbar(t_bunny_pixelarray *pix,\n                     t_progressbar      *prgrsbar);  Force update graphic of  prgrsbar inside pix`   t_button        *button_get(t_tekgui *gui, char *name);  Get a  t_button  from its  name   int         button_settext(t_tekgui     *gui,\n                       t_button     *button,\n                       char     *text);  Set the  text  of a  button   char            *button_gettext(t_button *button);  Get the text of a  button   char            *checkbox_gettext(t_checkbox *checkbox);  Get the text of a  t_checkbox   t_checkbox      *checkbox_get(t_tekgui *gui, char *name);  Get a  t_checkbox  from its name   int         checkbox_settext(t_tekgui   *gui,\n                     t_checkbox *checkbox,\n                     char       *text);  Set the  text   of a  checkbox   t_image         *image_get(t_tekgui *gui, char *name);  Retrieve a  t_image  from a  name   char            *image_getsrc(t_image *image);  Get the image  src   int         image_setsrc(t_tekgui   *gui,\n                     t_image    *image,\n                     char   *src);  Set the  image   src   int         display_label(t_bunny_pixelarray    *pix,\n                      t_label           *label,\n                      t_bunny_pixelarray    *font);  Force update graphics of a  t_label   t_textbox       *textbox_get(t_tekgui *gui, char *name);  retrieve  t_textbox  from its  name   char            *textbox_gettext(t_textbox *textbox);  Get text of a  t_textbox   int         textbox_settext(t_tekgui    *gui,\n                    t_textbox   *textbox,\n                    char        *text);  Set the text of a  t_textbox   int         display_image(t_bunny_pixelarray    *pix,\n                      t_image           *image,\n                      int           mode);  Force update the graphic of a  t_image   char            *getfield_safe(t_bunny_ini *ini,\n                       char *scope,\n                       char *field,\n                       int index);  Get a field from a  ini  with error management", 
            "title": "Functions"
        }, 
        {
            "location": "/en/function_list/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/en/function_list/#checkbox", 
            "text": "You can check if the state of a checkbox is equal to  CHECKED   UNCHECKED", 
            "title": "Checkbox"
        }, 
        {
            "location": "/en/function_list/#image", 
            "text": "There are different size mode for images :  STRETCHMODE_FILL  : The image fille the  size  in any way  STRETCHMODE_NONE  : The image is loaded normaly. If the  size  is bigger than the image, it is sticked at the top-left. If the  size  is smaller, the image is cropped  STRETCHMODE_CENTER  : The image is loaded normaly. If the  size  is bigger than the image, it is sticked at the center. If the  size  is smaller, the image is cropped", 
            "title": "Image"
        }, 
        {
            "location": "/en/function_list/#structures", 
            "text": "", 
            "title": "Structures"
        }, 
        {
            "location": "/en/function_list/#t_size", 
            "text": "int     width;\nint     height;  width  :  integer  : the width of the size  height  :  integer  : the height of the size", 
            "title": "t_size"
        }, 
        {
            "location": "/en/function_list/#t_text", 
            "text": "char                *text;\nint                 size;\nt_bunny_position    position;\nt_color             color;\nt_bunny_pixelarray  *pix;  char *   text  : the text that will be printed  t_size   size  : the size of the component  t_bunny_position   position  : the position of the component  t_color   color  : the color of the text  t_bunny_pixel_array *   pix  : the pixelarray where the text will be dislpayed", 
            "title": "t_text"
        }, 
        {
            "location": "/en/function_list/#t_button", 
            "text": "char            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;  char *   name  : the name of the button  t_bunny_position   pos  : The position of the button  t_size   size  : The size of the button  t_color   borderColor  : The color of the border of the button  integer   borderSize  : The size of the button's border (in pixels)  t_color   innerColor  : The button's inner color  char *   text  : The text of the button  integer   fontSize  : the font size of the button's text  t_color   fontColor  : The color of the button's text  ptrfct   onclick  : The function called when the  onclick  event occurs  ptrfct   onhover  : The function called when the  onhover  event occurs", 
            "title": "t_button"
        }, 
        {
            "location": "/en/function_list/#t_label", 
            "text": "char            *name;\nchar            *text;\nt_color     color;\nint         size;\nt_bunny_position    pos;  char *       name  : The name of the label  char *       text  : The text of the label  t_color       color  : The text color of the label  int           size  : The size of the label  t_bunny_position      pos  : The position of he label", 
            "title": "t_label"
        }, 
        {
            "location": "/en/function_list/#t_checkbox", 
            "text": "char            *name;\nint         state;\nt_size      size;\nt_color     backcolor;\nptrfct      oncheckstatechanged;\nt_label     *label;  char *           name  : The name of th checkbox  int           state  : The current state of the checkbox  t_size        size  : The size of the checkbox  ptrfct        oncheckstatechanged  : The function called when the  oncheckstatechanged  event occurs  t_label *        label  : The label linked to the checkbox", 
            "title": "t_checkbox"
        }, 
        {
            "location": "/en/function_list/#t_progressbar", 
            "text": "char            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     backColor;\nt_color     barColor;\nint         value;\nint         max;\nint         min;\nt_label     attached_text;  char *           name   The name of the progressbar   t_bunny_position      pos   The position of the progressbar   t_size        size   The size of the progressbar   t_color       borderColor   The color of the progressbar border   int           borderSize   The size of the progressbar's border   t_color       backColor   The back color of the progressbar   t_color       barColor   The color of the progressbar's bar   int           value   The current value of the progressbar   int           max   The max value of the progressbar   int           min   The minimum value of the progressbar   t_label       attached_text   The text attached to the progressbar", 
            "title": "t_progressbar"
        }, 
        {
            "location": "/en/function_list/#t_textbox", 
            "text": "char            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nchar            *placeholder;\nt_color     placeholder_color;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;\nptrfct      ontextchanged;\nint         waiting_for_text;  char *           name  : The name  t_bunny_position      pos  : The position  t_size        size  : The size  t_color       borderColor  : The border color  int           borderSize  : The border size  t_color       innerColor  : The inner coloor  char *           text  : The predefined text  char *           placeholder  : the placeholder (Appear if no text is typed)  t_color       placeholder_color  : The placeholder font color  int           fontSize  : The text font size  t_color       fontColor  : The text font color  ptrfct        onclick  : The function called when the  onclick  event occurs  ptrfct        onhover  : The function called when the  onhover  event occurs  ptrfct        ontextchanged  : The function called when the  ontextchanged  event occurs  int           waiting_for_text  : Set to 1 if the textbox is waiting text  i.e.  the textbox is selected", 
            "title": "t_textbox"
        }, 
        {
            "location": "/en/function_list/#t_image", 
            "text": "See the  Image macros  char            *name;\nint         borderSize;\nt_color     borderColor;\nchar            *src;\nt_size      size;\nt_bunny_position    pos;\nptrfct      onclick;  char *           name  : The name  int           borderSize  : the size of the border  t_color       borderColor  : The color of the border  char *           src  : The path to the image source  t_size        size  : The size of the frame where the image will be displayed  t_bunny_position      pos  : The position  ptrfct        onclick  : The function called when the  onclick  event occurs", 
            "title": "t_image"
        }, 
        {
            "location": "/en/function_list/#t_tekgui", 
            "text": "struct s_tekgui *child_win;\nint         child_win_nbr;\nt_button        *buttons;\nint         buttons_nbr;\nt_checkbox      *checkboxs;\nint         checkboxs_nbr;\nt_progressbar       *progressbars;\nint         progressbars_nbr;\nt_label     *labels;\nint         labels_nbr;\nt_textbox       *textboxs;\nint         textboxs_nbr;\nt_image     *images;\nint         images_nbr;\nt_bunny_ini     *config;\nt_size      size;\nt_bunny_window  *win;\nchar            *name;\nt_bunny_pixelarray  *pix;\nt_color     bgcolor;\nt_bunny_pixelarray  *font;\nt_bunny_pixelarray  **png_checkbox;\nt_callback_list callback;\ndouble      progress;\nvoid            *userdata;  struct s_tekgui   * child_win  : A pointer to windows child of the main window  int   child_win_nbr  : The number of child windows  t_button * buttons  : A pointer to the buttons  int   buttons_nbr  : The number of buttons  t_checkbox *   checkboxs  : A pointer to the checkboxs  int   checkboxs_nbr  : The number of checkboxs  t_progressbar *   progressbars  : A pointer to the progressbars  int   progressbars_nbr  : The number of progressbars  t_label *   labels  : A pointer to the labels  int   labels_nbr  : The number of labels  t_textbox *   textboxs  : A pointer to the textboxs  int   textboxs_nbr  : The number of textboxs  t_image *   images  : A pointer to the images  int   images_nbr  : The number of images  t_bunny_ini *   config  : The current config file  t_size   size  : The window original size  t_bunny_window *   win  : The  t_buny_window  component (for sharing)  char *   name  : The window name  t_bunny_pixelarray *   pix  : The render  pixelarray  t_color   bgcolor  : The background color  t_bunny_pixelarray *   font  : The font file  t_bunny_pixelarray **   png_checkbox  : The checkbox image ressource  void *   userdata  : The variable where the user can put his datas", 
            "title": "t_tekgui"
        }, 
        {
            "location": "/en/function_list/#tips-and-tricks", 
            "text": "You can define colors in several ways \nIf you have an  unsigned int  : 0xff0000 \nBut you need a  t_color , you can simply do this :  t_color color;\nunsigned int c;\n\nc = 0xff0000;\ncolor.full = c;  It will convert your  unsigned int  to a  t_color \nIn reverse you can do this too  t_color color;\nunsigned int c;\n\ncolor.argb[0] = 255;\ncolor.argb[1] = 0;\ncolor.argb[2] = 0;\nc = color.full;", 
            "title": "Tips and tricks"
        }, 
        {
            "location": "/keys/", 
            "text": "Key list\n\n\nBKS_UNKNOWN         = -1,\nBKS_A,\nBKS_B,\nBKS_C,\nBKS_D,\nBKS_E,\nBKS_F,\nBKS_G,\nBKS_H,\nBKS_I,\nBKS_J,\nBKS_K,\nBKS_L,\nBKS_M,\nBKS_N,\nBKS_O,\nBKS_P,\nBKS_Q,\nBKS_R,\nBKS_S,\nBKS_T,\nBKS_U,\nBKS_V,\nBKS_W,\nBKS_X,\nBKS_Y,\nBKS_Z,\nBKS_0,\nBKS_1,\nBKS_2,\nBKS_3,\nBKS_4,\nBKS_5,\nBKS_6,\nBKS_7,\nBKS_8,\nBKS_9,\nBKS_ESCAPE,\nBKS_LCONTROL,\nBKS_LSHIFT,\nBKS_LALT,\nBKS_LSYSTEM,\nBKS_RCONTROL,\nBKS_RSHIFT,\nBKS_RALT,\nBKS_RSYSTEM,\nBKS_MENU,\nBKS_LBRACKET,\nBKS_RBRACKET,\nBKS_SEMICOLON,\nBKS_COMMA,\nBKS_PERIOD,\nBKS_QUOTE,\nBKS_SLASH,\nBKS_BACKSLASH,\nBKS_TILDE,\nBKS_EQUAL,\nBKS_DASH,\nBKS_SPACE,\nBKS_RETURN,\nBKS_BACKSPACE,\nBKS_TAB,\nBKS_PAGEUP,\nBKS_PAGEDOWN,\nBKS_END,\nBKS_HOME,\nBKS_INSERT,\nBKS_DELETE,\nBKS_ADD,\nBKS_SUBTRACT,\nBKS_MULTIPLY,\nBKS_DIVIDE,\nBKS_LEFT,\nBKS_RIGHT,\nBKS_UP,\nBKS_DOWN,\nBKS_NUMPAD0,\nBKS_NUMPAD1,\nBKS_NUMPAD2,\nBKS_NUMPAD3,\nBKS_NUMPAD4,\nBKS_NUMPAD5,\nBKS_NUMPAD6,\nBKS_NUMPAD7,\nBKS_NUMPAD8,\nBKS_NUMPAD9,\nBKS_F1,\nBKS_F2,\nBKS_F3,\nBKS_F4,\nBKS_F5,\nBKS_F6,\nBKS_F7,\nBKS_F8,\nBKS_F9,\nBKS_F10,\nBKS_F11,\nBKS_F12,\nBKS_F13,\nBKS_F14,\nBKS_F15,\nBKS_PAUSE,\nBKS_LAST_KEY\n\n\n\n\nState list\n\n\nGO_DOWN\n is the state when the key is pressed\n\n\nGO_UP\n is the state when the key is released", 
            "title": "Clavier"
        }, 
        {
            "location": "/keys/#key-list", 
            "text": "BKS_UNKNOWN         = -1,\nBKS_A,\nBKS_B,\nBKS_C,\nBKS_D,\nBKS_E,\nBKS_F,\nBKS_G,\nBKS_H,\nBKS_I,\nBKS_J,\nBKS_K,\nBKS_L,\nBKS_M,\nBKS_N,\nBKS_O,\nBKS_P,\nBKS_Q,\nBKS_R,\nBKS_S,\nBKS_T,\nBKS_U,\nBKS_V,\nBKS_W,\nBKS_X,\nBKS_Y,\nBKS_Z,\nBKS_0,\nBKS_1,\nBKS_2,\nBKS_3,\nBKS_4,\nBKS_5,\nBKS_6,\nBKS_7,\nBKS_8,\nBKS_9,\nBKS_ESCAPE,\nBKS_LCONTROL,\nBKS_LSHIFT,\nBKS_LALT,\nBKS_LSYSTEM,\nBKS_RCONTROL,\nBKS_RSHIFT,\nBKS_RALT,\nBKS_RSYSTEM,\nBKS_MENU,\nBKS_LBRACKET,\nBKS_RBRACKET,\nBKS_SEMICOLON,\nBKS_COMMA,\nBKS_PERIOD,\nBKS_QUOTE,\nBKS_SLASH,\nBKS_BACKSLASH,\nBKS_TILDE,\nBKS_EQUAL,\nBKS_DASH,\nBKS_SPACE,\nBKS_RETURN,\nBKS_BACKSPACE,\nBKS_TAB,\nBKS_PAGEUP,\nBKS_PAGEDOWN,\nBKS_END,\nBKS_HOME,\nBKS_INSERT,\nBKS_DELETE,\nBKS_ADD,\nBKS_SUBTRACT,\nBKS_MULTIPLY,\nBKS_DIVIDE,\nBKS_LEFT,\nBKS_RIGHT,\nBKS_UP,\nBKS_DOWN,\nBKS_NUMPAD0,\nBKS_NUMPAD1,\nBKS_NUMPAD2,\nBKS_NUMPAD3,\nBKS_NUMPAD4,\nBKS_NUMPAD5,\nBKS_NUMPAD6,\nBKS_NUMPAD7,\nBKS_NUMPAD8,\nBKS_NUMPAD9,\nBKS_F1,\nBKS_F2,\nBKS_F3,\nBKS_F4,\nBKS_F5,\nBKS_F6,\nBKS_F7,\nBKS_F8,\nBKS_F9,\nBKS_F10,\nBKS_F11,\nBKS_F12,\nBKS_F13,\nBKS_F14,\nBKS_F15,\nBKS_PAUSE,\nBKS_LAST_KEY", 
            "title": "Key list"
        }, 
        {
            "location": "/keys/#state-list", 
            "text": "GO_DOWN  is the state when the key is pressed  GO_UP  is the state when the key is released", 
            "title": "State list"
        }, 
        {
            "location": "/en/basics/", 
            "text": "Welcome to the tutorial of LibTekGui\n\n\nSetup\n\n\nFirst, create a folder \nlib\n at the root of your project if it doesn't exist and put the file \nlibtekgui.a\n inside.\n\n\nNow, you have to edit you Makefile :\n\n\nAdd \nLIB_TEKGUI = -Llib -ltekgui\n in your variables section and \n$(LIB_TEKGUI)\n in your compilation line If you don't use Makefile, run cc/gcc command with \n-Llib -ltekgui\n at the end.\n\n\nThat's all !\n\n\nMinimum code\n\n\nYou need at least a \nmain.c\n and a \nconfiguration.ini\n file.\n\n\nMain file\n\n\nHere is an example of a basic \nmain.c\n file :\n\n\nint main()\n{\n  t_tekgui      *gui;\n\n   gui = tekgui_load(\nfull.ini\n);\n   gui-\npix = bunny_new_pixelarray(gui-\nsize.width, gui-\nsize.height);\n   tekgui_display(gui-\npix, gui);\n   tekgui_show(gui);\n   return(0);\n}\n\n\n\n\nt_tekgui\n is a structure that contains all the required datas.\n\n\nTo set this var, you have to use \ntekgui_load\n and pass a configuration file as parameter.\n\n\ntekgui_display\n is used to put all the data of the \ngui\n to a \npixelarray\n \n1\n. There is already a predefined \npixelarray\n \n1\n inside \nt_tekgui\n\n\nAnd finally, \ntekgui_show\n display a window with all the content of \ngui\n and \ngui-\npix\n\n\nConfiguration file\n\n\nHere is an example of a basic \nconfiguration.ini\n file :\n\n\n[win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240\n\n\n\n\nThis file will show an empty window of size \n500\nx\n500\n, with the name \nmy_name\n and with the background color \n240\n,\n240\n,\n240\n that is a light grey as the Windows's window background.\n\n\nA preview with the current settings :\n\n\n\n\nYou can now go to the second part to learn how to \nBuild an ini file\n\n\n\n\n\n\n\n\n\n\nA pixelarray is a an array of pixels that contains color data.", 
            "title": "Basics"
        }, 
        {
            "location": "/en/basics/#welcome-to-the-tutorial-of-libtekgui", 
            "text": "", 
            "title": "Welcome to the tutorial of LibTekGui"
        }, 
        {
            "location": "/en/basics/#setup", 
            "text": "First, create a folder  lib  at the root of your project if it doesn't exist and put the file  libtekgui.a  inside.  Now, you have to edit you Makefile :  Add  LIB_TEKGUI = -Llib -ltekgui  in your variables section and  $(LIB_TEKGUI)  in your compilation line If you don't use Makefile, run cc/gcc command with  -Llib -ltekgui  at the end.  That's all !", 
            "title": "Setup"
        }, 
        {
            "location": "/en/basics/#minimum-code", 
            "text": "You need at least a  main.c  and a  configuration.ini  file.", 
            "title": "Minimum code"
        }, 
        {
            "location": "/en/basics/#main-file", 
            "text": "Here is an example of a basic  main.c  file :  int main()\n{\n  t_tekgui      *gui;\n\n   gui = tekgui_load( full.ini );\n   gui- pix = bunny_new_pixelarray(gui- size.width, gui- size.height);\n   tekgui_display(gui- pix, gui);\n   tekgui_show(gui);\n   return(0);\n}  t_tekgui  is a structure that contains all the required datas.  To set this var, you have to use  tekgui_load  and pass a configuration file as parameter.  tekgui_display  is used to put all the data of the  gui  to a  pixelarray   1 . There is already a predefined  pixelarray   1  inside  t_tekgui  And finally,  tekgui_show  display a window with all the content of  gui  and  gui- pix", 
            "title": "Main file"
        }, 
        {
            "location": "/en/basics/#configuration-file", 
            "text": "Here is an example of a basic  configuration.ini  file :  [win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240  This file will show an empty window of size  500 x 500 , with the name  my_name  and with the background color  240 , 240 , 240  that is a light grey as the Windows's window background.  A preview with the current settings :   You can now go to the second part to learn how to  Build an ini file      A pixelarray is a an array of pixels that contains color data.", 
            "title": "Configuration file"
        }, 
        {
            "location": "/en/building_ini/", 
            "text": "Building you ini\n\n\nBasics\n\n\nA basic ini is at least composed of :\n\n\n[win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240\n\n\n\n\nBut, what it means ?\n\n\n[win]\n means that we are working in the \nscope\n \nwin\n which refer to the main window. There can be as many \n__scopes\n as you want in an ini file.\n\n\nwidth\n, \nheight\n, \nname\n, \nbgcolor\n are \nfields\n. The \nfields\n are contained inside a \nscope\n. It is based on a key/value system. The key is \nwidth\n and the value \n500\n.\n\n\nIt is as simple as this !\n\n\nSupported fields\n\n\nThere are many supported fields in this library. The ini is designed to be simple to setup.\n\n\nIf you want for example to add a button, just add a \nscope\n with all the keys needed by your button. Then add a \nbuttons\n key and add all your buttons scopes followed by coma.\n\nMake sure all your datas a right, else you will get errors.\n\n\n[win]\nwidth=500\nheight=500\nname=loooul\nbgcolor=240,240,240\nbuttons=btn1,btn2\n\n[btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext=\nOK\n\nfontColor=0,0,0\ntextalign=center\nonclick=btn1_ok\n\n[btn2]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext=\nCancel\n\nfontColor=0,0,0\ntextalign=center\nonclick=btn2_cancel\n\n\n\n\nThis render as this :\n\n\n\n\n\n\n\nNow that you know how to build your ini, you should read this sections that list all the components and keys required by it\n\n\nView all the components", 
            "title": "How to build an ini"
        }, 
        {
            "location": "/en/building_ini/#building-you-ini", 
            "text": "", 
            "title": "Building you ini"
        }, 
        {
            "location": "/en/building_ini/#basics", 
            "text": "A basic ini is at least composed of :  [win]\nwidth=500\nheight=500\nname=my_name\nbgcolor=240,240,240  But, what it means ?  [win]  means that we are working in the  scope   win  which refer to the main window. There can be as many  __scopes  as you want in an ini file.  width ,  height ,  name ,  bgcolor  are  fields . The  fields  are contained inside a  scope . It is based on a key/value system. The key is  width  and the value  500 .  It is as simple as this !", 
            "title": "Basics"
        }, 
        {
            "location": "/en/building_ini/#supported-fields", 
            "text": "There are many supported fields in this library. The ini is designed to be simple to setup.  If you want for example to add a button, just add a  scope  with all the keys needed by your button. Then add a  buttons  key and add all your buttons scopes followed by coma. \nMake sure all your datas a right, else you will get errors.  [win]\nwidth=500\nheight=500\nname=loooul\nbgcolor=240,240,240\nbuttons=btn1,btn2\n\n[btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext= OK \nfontColor=0,0,0\ntextalign=center\nonclick=btn1_ok\n\n[btn2]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=12\npos=10,10\nsize=150,50\ntext= Cancel \nfontColor=0,0,0\ntextalign=center\nonclick=btn2_cancel  This render as this :    Now that you know how to build your ini, you should read this sections that list all the components and keys required by it  View all the components", 
            "title": "Supported fields"
        }, 
        {
            "location": "/en/components/", 
            "text": "Data types\n\n\nColor\n\n\nA color is a set of 3 values, between 0 and 255, separated by commas. \n ex: \n26,22,128\n \n The color is \n\n\nPosition\n\n\nA position is a set of 2 values, separated by comas \n ex: \n50,100\n \n This position is relative to the window\n\n\nSize\n\n\nA size is a set of 2 values, separated by comas \n ex: \n16,16\n \n This position is relative to the window\n\n\nString\n\n\nA string is a list of char \n ex: \n\"Hello\"\n \n A string is always between double quotes \" \"\n\n\nFunction name\n\n\nA Function name is a string that correspond to a function inside your code \n ex: \ntekgui_load\n\n\nComponents\n\n\nWindow\n\n\nInside your \nwin\n \nscope\n :\n\n\nwidth\n require a integer\n\n\nheight\n require a integer\n\n\nname\n require a \nstring\n\n\nButton\n\n\n\n\nInside \nwin\n \nscope\n :\n\n\nbuttons=btn1,btn2\n\n[btn1]\n...\n\n\n\n\nInside your button \nscope\n :\n\n\nborderColor\n require a \ncolor\n\n\ninnerColor\n require a \ncolor\n\n\nborderSize\n require integer (size in pixels)\n\n\npos\n require a \nposition\n\n\nsize\n require a \nsize\n\n\ntext\n require a \nstring\n\n\nfontColor\n require a \ncolor\n\n\nonclick\n require a \nfunction name\n\n\nCheckbox\n\n\n\n\nInside \nwin\n \nscope\n :\n\n\ncheckboxs=checkboxs1,checkboxs2\n\n[checkboxs1]\n...\n\n\n\n\nInside your checkbox \nscope\n :\n\n\nfontSize\n require integer (size in pixels)\n\n\nfontColor\n  require a \ncolor\n\n\npos\n require a \nposition\n\n\nsize\n require a \nsize\n\n\ntext\n require a \nstring\n\n\noncheckstatechanged\n require a \nfunction name\n\n\nImage\n\n\nInside \nwin\n \nscope\n :\n\n\nimages=img1\n\n[img1]\n...\n\n\n\n\nInside your image \nscope\n :\n\n\npos\n require a \nposition\n\n\nsize\n require a \nsize\n\n\nonclick\n require a \nfunction name\n\n\nborderSize\n require a integer\n\n\nborderColor\n require a \ncolor\n\n\nsrc\n require a \nstring\n\n\nLabel\n\n\n\n\nInside \nwin\n \nscope\n :\n\n\nlabels=label1,label2\n\n[label1]\n...\n\n\n\n\nInside your image \nscope\n :\n\n\npos\n require a \nposition\n\n\nfontSize\n require a integer\n\n\nfontColor\n require a \ncolor\n\n\ntext\n require a \nstring\n\n\nProgressbar\n\n\n\n\n\n\nInside \nwin\n \nscope\n :\n\n\nprogressbars=pgrsbar\n\n[pgrsbar]\n...\n\n\n\n\nInside your progressbar \nscope\n :\n\n\nborderColor\n require a \ncolor\n\n\nborderSize\n require a integer\n\n\nbackColor\n require a \ncolor\n\n\nbarColor\n require a \ncolor\n\n\npos\n require a \nposition\n\n\nsize\n require a integer\n\n\nvalue\n require a integer\n\n\nmax, min\n require a integer\n\n\nTextbox\n\n\n\n\nInside \nwin\n \nscope\n :\n\n\ntextboxs=tb\n\n[tb]\n...\n\n\n\n\nInside your textbox \nscope\n :\n\n\nborderColor\n require a \ncolor\n\n\nborderSize\n require a integer\n\n\nfontColor\n require a \ncolor\n\n\nfontSize\n require a integer\n\n\ninnerColor\n require a \ncolor\n\n\npos\n require a \nposition\n\n\nsize\n require a integer\n\n\nplaceholder\n require a \nstring\n\n\nplaceholderColor\n require a \ncolor\n\n\nontextentered\n require a \nfunction name\n\n\nonclick\n require a \nfunction name", 
            "title": "Components configuration"
        }, 
        {
            "location": "/en/components/#data-types", 
            "text": "", 
            "title": "Data types"
        }, 
        {
            "location": "/en/components/#color", 
            "text": "A color is a set of 3 values, between 0 and 255, separated by commas.   ex:  26,22,128    The color is", 
            "title": "Color"
        }, 
        {
            "location": "/en/components/#position", 
            "text": "A position is a set of 2 values, separated by comas   ex:  50,100    This position is relative to the window", 
            "title": "Position"
        }, 
        {
            "location": "/en/components/#size", 
            "text": "A size is a set of 2 values, separated by comas   ex:  16,16    This position is relative to the window", 
            "title": "Size"
        }, 
        {
            "location": "/en/components/#string", 
            "text": "A string is a list of char   ex:  \"Hello\"    A string is always between double quotes \" \"", 
            "title": "String"
        }, 
        {
            "location": "/en/components/#function-name", 
            "text": "A Function name is a string that correspond to a function inside your code   ex:  tekgui_load", 
            "title": "Function name"
        }, 
        {
            "location": "/en/components/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/en/components/#window", 
            "text": "Inside your  win   scope  :  width  require a integer  height  require a integer  name  require a  string", 
            "title": "Window"
        }, 
        {
            "location": "/en/components/#button", 
            "text": "Inside  win   scope  :  buttons=btn1,btn2\n\n[btn1]\n...  Inside your button  scope  :  borderColor  require a  color  innerColor  require a  color  borderSize  require integer (size in pixels)  pos  require a  position  size  require a  size  text  require a  string  fontColor  require a  color  onclick  require a  function name", 
            "title": "Button"
        }, 
        {
            "location": "/en/components/#checkbox", 
            "text": "Inside  win   scope  :  checkboxs=checkboxs1,checkboxs2\n\n[checkboxs1]\n...  Inside your checkbox  scope  :  fontSize  require integer (size in pixels)  fontColor   require a  color  pos  require a  position  size  require a  size  text  require a  string  oncheckstatechanged  require a  function name", 
            "title": "Checkbox"
        }, 
        {
            "location": "/en/components/#image", 
            "text": "Inside  win   scope  :  images=img1\n\n[img1]\n...  Inside your image  scope  :  pos  require a  position  size  require a  size  onclick  require a  function name  borderSize  require a integer  borderColor  require a  color  src  require a  string", 
            "title": "Image"
        }, 
        {
            "location": "/en/components/#label", 
            "text": "Inside  win   scope  :  labels=label1,label2\n\n[label1]\n...  Inside your image  scope  :  pos  require a  position  fontSize  require a integer  fontColor  require a  color  text  require a  string", 
            "title": "Label"
        }, 
        {
            "location": "/en/components/#progressbar", 
            "text": "Inside  win   scope  :  progressbars=pgrsbar\n\n[pgrsbar]\n...  Inside your progressbar  scope  :  borderColor  require a  color  borderSize  require a integer  backColor  require a  color  barColor  require a  color  pos  require a  position  size  require a integer  value  require a integer  max, min  require a integer", 
            "title": "Progressbar"
        }, 
        {
            "location": "/en/components/#textbox", 
            "text": "Inside  win   scope  :  textboxs=tb\n\n[tb]\n...  Inside your textbox  scope  :  borderColor  require a  color  borderSize  require a integer  fontColor  require a  color  fontSize  require a integer  innerColor  require a  color  pos  require a  position  size  require a integer  placeholder  require a  string  placeholderColor  require a  color  ontextentered  require a  function name  onclick  require a  function name", 
            "title": "Textbox"
        }, 
        {
            "location": "/en/functions/", 
            "text": "Interactions\n\n\nNow that you know how to design your basic interface, what about interacting with it ?\n\n\nInteracting with components\n\n\nThere are several function to make your life easier\n\nAll the function are based on the name of your component.\n\nto refresh a bit your memeory, the name of your component is his \nscope\n\n\nOk, say we have a button like this :\n\n\n[btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=1\npos=10,10\nsize=150,50\ntext=\nOK\n\nfontColor=0,0,0\nonclick=click\n\n\n\n\nAnd i want to grab the current state of the button loaded in memory, what should I do ?\n\nI just have the function : \nbutton_get\n\n\nHere is how to use it :\n\n\nt_button  *button;\n\nbutton = button_get(gui, \nbtn1\n)\nbutton-\ntext = \nHello\n;\n\n\n\n\nIf you don't want to define a variable, to reduce code size, you can also do it this way :\n\n\nbutton_get(gui, \nbtn1\n)-\ntext = \nBonjour\n;\n\n\n\n\nNow you can interact with your button and access all it's components\n\nIt also works for all the components\n\nI invite you to read the \nfunction list\n to know all the capabilities.\n\n\nAdding keybindings\n\n\nYou can define your own keybindings with a simple function :\n\n\ntekgui_addkeytrigger(gui, BKS_J, \nclick\n, GO_DOWN);\n\n\n\n\nWhere \ngui\n is the \nt_tekgui\n component\n\n\nBKS_J\n is the key (see the \nkeylist\n)\n\n\n\"click\"\n is the function name that will be called\n\n\nGO_DOWN\n is the state of the key (see the \nstate list\n)\n\n\nAdding new components\n\n\nTODO\n\n\nUser utility\n\n\nIt's cool to add custom triggers but how can I get custom values ?\n\nThe answer is \nuserdata\n !\n\nin fact, inside the \nt_tekgui\n structure there is a variable called \nuserdata\n of type \nvoid *\n\n\nYou don't know how to use it ?\n\nIt's easy :\n\n\n\n\ndefine a custom structure\n\n\n\n\ntypedef struct  s_myuserstructure\n{\n    char        *text;\n}                t_myuserstructure;\n\n\n\n\n\n\nPut it in your main\n\n\n\n\n//Define structure\nt_myuserstructure   st;\n\n//Set data inside structure\nst.text = \nBonjour\n;\n\n//Set userdata equal to your datas\ngui-\nuserdata = \nst;\n\n\n\n\n\n\nEvery trigger receive the \nt_tekgui\n structure\n\nGrab your datas like this :\n\n\n\n\n//Function triggered when a button is clicked\nvoid            click(void *data)\n{\n  //Define t_tekgui and t_myuserstructure\n  t_tekgui      *gui;\n  t_myuserstructure *st;\n\n  //get gui structure from data\n  gui = (t_tekgui *) data;\n\n  //get your structure from userdata\n  st = (t_myuserstructure *) gui-\nuserdata;\n\n  //Now feel free to use you data as want :)\n  my_putstr(st-\ntext);\n}", 
            "title": "Functions"
        }, 
        {
            "location": "/en/functions/#interactions", 
            "text": "Now that you know how to design your basic interface, what about interacting with it ?", 
            "title": "Interactions"
        }, 
        {
            "location": "/en/functions/#interacting-with-components", 
            "text": "There are several function to make your life easier \nAll the function are based on the name of your component. \nto refresh a bit your memeory, the name of your component is his  scope  Ok, say we have a button like this :  [btn1]\nborderColor=112,112,112\ninnerColor=212,212,212\nborderSize=1\nfontSize=1\npos=10,10\nsize=150,50\ntext= OK \nfontColor=0,0,0\nonclick=click  And i want to grab the current state of the button loaded in memory, what should I do ? \nI just have the function :  button_get  Here is how to use it :  t_button  *button;\n\nbutton = button_get(gui,  btn1 )\nbutton- text =  Hello ;  If you don't want to define a variable, to reduce code size, you can also do it this way :  button_get(gui,  btn1 )- text =  Bonjour ;  Now you can interact with your button and access all it's components \nIt also works for all the components \nI invite you to read the  function list  to know all the capabilities.", 
            "title": "Interacting with components"
        }, 
        {
            "location": "/en/functions/#adding-keybindings", 
            "text": "You can define your own keybindings with a simple function :  tekgui_addkeytrigger(gui, BKS_J,  click , GO_DOWN);  Where  gui  is the  t_tekgui  component  BKS_J  is the key (see the  keylist )  \"click\"  is the function name that will be called  GO_DOWN  is the state of the key (see the  state list )", 
            "title": "Adding keybindings"
        }, 
        {
            "location": "/en/functions/#adding-new-components", 
            "text": "TODO", 
            "title": "Adding new components"
        }, 
        {
            "location": "/en/functions/#user-utility", 
            "text": "It's cool to add custom triggers but how can I get custom values ? \nThe answer is  userdata  ! \nin fact, inside the  t_tekgui  structure there is a variable called  userdata  of type  void *  You don't know how to use it ? \nIt's easy :   define a custom structure   typedef struct  s_myuserstructure\n{\n    char        *text;\n}                t_myuserstructure;   Put it in your main   //Define structure\nt_myuserstructure   st;\n\n//Set data inside structure\nst.text =  Bonjour ;\n\n//Set userdata equal to your datas\ngui- userdata =  st;   Every trigger receive the  t_tekgui  structure \nGrab your datas like this :   //Function triggered when a button is clicked\nvoid            click(void *data)\n{\n  //Define t_tekgui and t_myuserstructure\n  t_tekgui      *gui;\n  t_myuserstructure *st;\n\n  //get gui structure from data\n  gui = (t_tekgui *) data;\n\n  //get your structure from userdata\n  st = (t_myuserstructure *) gui- userdata;\n\n  //Now feel free to use you data as want :)\n  my_putstr(st- text);\n}", 
            "title": "User utility"
        }, 
        {
            "location": "/en/function_list/", 
            "text": "Functions\n\n\nt_tekgui    *tekgui_load(const char *file);\n\n\n\n\nLoad a configuration file \nfile\n inside a \nt_tekgui *\n\n\n\n\nvoid        tekgui_unload(t_tekgui *tekgui);\n\n\n\n\nUnload \ntekgui\n from the memory\n\n\n\n\nvoid        tekgui_display(t_bunny_pixelarray   *pix,\n                           t_tekgui             *gui);\n\n\n\n\nPut the graphical representation of \ngui\n inside \npix\n\n\n\n\nvoid        fill_color(t_bunny_pixelarray   *pixelarray,\n                        unsigned int        color);\n\n\n\n\nFill completely \npixelarray\n wiht the color \ncolor\n\n\n\n\nvoid            set_max_heap_size(size_t);\n\n\n\n\nSet the max ram for the program\n\n\n\n\nvoid            tekpixel(t_bunny_pixelarray *a,\n                 t_bunny_position   *p,\n                 t_color        *c);\n\n\n\n\nSet the color of a pixel at the position \np\n, of color \nc\n and inside \na\n\n\n\n\nt_bunny_position    new_bunny_position(int x, int y);\n\n\n\n\nCreate a \nt_bunny_position\n from \nx\n and \ny\n\n\n\n\nt_size          new_size(int w, int h);\n\n\n\n\nCreate a \nt_size\n from  width \nw\n and height \nh\n\n\n\n\nvoid            tekline(t_bunny_pixelarray  *pix,\n                t_bunny_position    *pos,\n                t_color         *color);\n\n\n\n\nDraw a line inside \npix\n from \npos[0]\n to \npos[1]\n of color \ncolor\n\n\n\n\nint         tekgui_putstring(t_text         text,\n                     t_bunny_pixelarray *pix,\n                     t_bunny_pixelarray *font);\n\n\n\n\nPut a string from a \nt_text\n inside \npix\n with the font \nfont\n\n\n\n\nunsigned int        tekgetpixel(t_bunny_pixelarray  *a,\n                    t_bunny_position    *p);\n\n\n\n\nreturn in an \nunsigned int\n the pixel color at \np\n inside \na\n\n\n\n\nt_color         new_color(int r, int g, int b, int a);\n\n\n\n\nCreate a \nt_color\n from \nr\n, \ng\n, \nb\n and \na\n component\n\n\n\n\nt_color         load_ini_color(t_bunny_ini *ini,\n                       char *field,\n                       char *name);\n\n\n\n\nload a \nt_color\n from \nini\n at \nfield\n-\nname\n\n\n\n\nvoid            *tekfunction(const char *funcname);\n\n\n\n\nReturn a function pointer from a \nchar *\n name\n\n\n\n\nint         is_hover(t_bunny_position   *from_pos,\n                 t_bunny_position   *pos,\n                 t_size         *size);\n\n\n\n\nDetermine if the position \nfrom_pos\n is inside the rectangle \npos-size\n\n\n\n\nint         display_button(t_bunny_pixelarray   *pix,\n                       t_button         *button,\n                       t_bunny_pixelarray   *font);\n\n\n\n\nUpdate the graphics of \nbutton\n inside \npix\n with the font \nfont\n\n\n\n\nt_size          load_ini_size(t_bunny_ini *ini, char *scope);\n\n\n\n\nload a \nt_size\n from a \nscope\n inside \nini\n\n\n\n\nt_bunny_position    load_ini_position(t_bunny_ini *ini, char *scope);\n\n\n\n\n\nLoad a  \nt_bunny_position\n from \nscope\n inside \nini\n\n\n\n\nint         display_textbox(t_bunny_pixelarray  *pix,\n                    t_textbox       *textbox,\n                    t_bunny_pixelarray  *font);\n\n\n\n\nUpdate the graphics of a \ntextbox\n inside \npix\n wiht the \nfont\n\n\n\n\nvoid            check_box(t_tekgui *gui, t_checkbox *checkbox);\n\n\n\n\nForce checking \ncheckbox\n\n\n\n\nvoid            uncheck_box(t_tekgui *gui, t_checkbox *checkbox);\n\n\n\n\nForce unchecking \ncheckbox\n\n\n\n\nint         display_checkbox(t_bunny_pixelarray *pix,\n                     t_checkbox     *checkbox,\n                     t_bunny_pixelarray *font,\n                     t_bunny_pixelarray **png_checkbox);\n\n\n\n\nupdate the graphics of \ncheckbox\n inside \npix\n, with \nfont\n and \npng_checkbox\n graphics\n\n\n\n\nvoid            tekgui_show(t_tekgui        *gui);\n\n\n\n\nOpen a window a show the \ngui\n\n\n\n\nt_bunny_pixelarray  *stretch(t_bunny_pixelarray *oldpixel,\n                 int            newx,\n                 int            newy);\n\n\n\n\nStretch an an image inside \noldpixel\n to be resize to \nnewx, newy\n\n\n\n\nt_progressbar       *progressbar_get(t_tekgui *gui, char *name);\n\n\n\n\nGet a progressbar by its \nname\n\n\n\n\nint         progressbar_setprogress(t_tekgui        *gui,\n                        t_progressbar       *progressbar,\n                        int         progress);\n\n\n\n\nSet the \nprogressbar\n progress to \nprogress\n\n\n\n\nint         progressbar_getprogress(t_progressbar *progressbar);\n\n\n\n\nget the current progress from a \nprogressbar\n\n\n\n\nint         display_prgrsbar(t_bunny_pixelarray *pix,\n                     t_progressbar      *prgrsbar);\n\n\n\n\nForce update graphic of \nprgrsbar inside\npix`\n\n\n\n\nt_button        *button_get(t_tekgui *gui, char *name);\n\n\n\n\nGet a \nt_button\n from its \nname\n\n\n\n\nint         button_settext(t_tekgui     *gui,\n                       t_button     *button,\n                       char     *text);\n\n\n\n\nSet the \ntext\n of a \nbutton\n\n\n\n\nchar            *button_gettext(t_button *button);\n\n\n\n\nGet the text of a \nbutton\n\n\n\n\nchar            *checkbox_gettext(t_checkbox *checkbox);\n\n\n\n\nGet the text of a \nt_checkbox\n\n\n\n\nt_checkbox      *checkbox_get(t_tekgui *gui, char *name);\n\n\n\n\nGet a \nt_checkbox\n from its name\n\n\n\n\nint         checkbox_settext(t_tekgui   *gui,\n                     t_checkbox *checkbox,\n                     char       *text);\n\n\n\n\nSet the \ntext\n  of a \ncheckbox\n\n\n\n\nt_image         *image_get(t_tekgui *gui, char *name);\n\n\n\n\nRetrieve a \nt_image\n from a \nname\n\n\n\n\nchar            *image_getsrc(t_image *image);\n\n\n\n\nGet the image \nsrc\n\n\n\n\nint         image_setsrc(t_tekgui   *gui,\n                     t_image    *image,\n                     char   *src);\n\n\n\n\nSet the \nimage\n \nsrc\n\n\n\n\nint         display_label(t_bunny_pixelarray    *pix,\n                      t_label           *label,\n                      t_bunny_pixelarray    *font);\n\n\n\n\nForce update graphics of a \nt_label\n\n\n\n\nt_textbox       *textbox_get(t_tekgui *gui, char *name);\n\n\n\n\nretrieve \nt_textbox\n from its \nname\n\n\n\n\nchar            *textbox_gettext(t_textbox *textbox);\n\n\n\n\nGet text of a \nt_textbox\n\n\n\n\nint         textbox_settext(t_tekgui    *gui,\n                    t_textbox   *textbox,\n                    char        *text);\n\n\n\n\nSet the text of a \nt_textbox\n\n\n\n\nint         display_image(t_bunny_pixelarray    *pix,\n                      t_image           *image,\n                      int           mode);\n\n\n\n\nForce update the graphic of a \nt_image\n\n\n\n\nchar            *getfield_safe(t_bunny_ini *ini,\n                       char *scope,\n                       char *field,\n                       int index);\n\n\n\n\nGet a field from a \nini\n with error management\n\n\nMacros\n\n\nCheckbox\n\n\nYou can check if the state of a checkbox is equal to \nCHECKED\n \nUNCHECKED\n\n\nImage\n\n\nThere are different size mode for images :\n\n\nSTRETCHMODE_FILL\n : The image fille the \nsize\n in any way\n\n\nSTRETCHMODE_NONE\n : The image is loaded normaly. If the \nsize\n is bigger than the image, it is sticked at the top-left. If the \nsize\n is smaller, the image is cropped\n\n\nSTRETCHMODE_CENTER\n : The image is loaded normaly. If the \nsize\n is bigger than the image, it is sticked at the center. If the \nsize\n is smaller, the image is cropped\n\n\nStructures\n\n\nt_size\n\n\nint     width;\nint     height;\n\n\n\n\nwidth\n : \ninteger\n : the width of the size\n\n\nheight\n : \ninteger\n : the height of the size\n\n\nt_text\n\n\nchar                *text;\nint                 size;\nt_bunny_position    position;\nt_color             color;\nt_bunny_pixelarray  *pix;\n\n\n\n\nchar *\n \ntext\n : the text that will be printed\n\n\nt_size\n \nsize\n : the size of the component\n\n\nt_bunny_position\n \nposition\n : the position of the component\n\n\nt_color\n \ncolor\n : the color of the text\n\n\nt_bunny_pixel_array *\n \npix\n : the pixelarray where the text will be dislpayed\n\n\nt_button\n\n\nchar            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;\n\n\n\n\nchar *\n \nname\n : the name of the button\n\n\nt_bunny_position\n \npos\n : The position of the button\n\n\nt_size\n \nsize\n : The size of the button\n\n\nt_color\n \nborderColor\n : The color of the border of the button\n\n\ninteger\n \nborderSize\n : The size of the button's border (in pixels)\n\n\nt_color\n \ninnerColor\n : The button's inner color\n\n\nchar *\n \ntext\n : The text of the button\n\n\ninteger\n \nfontSize\n : the font size of the button's text\n\n\nt_color\n \nfontColor\n : The color of the button's text\n\n\nptrfct\n \nonclick\n : The function called when the \nonclick\n event occurs\n\n\nptrfct\n \nonhover\n : The function called when the \nonhover\n event occurs\n\n\nt_label\n\n\nchar            *name;\nchar            *text;\nt_color     color;\nint         size;\nt_bunny_position    pos;\n\n\n\n\nchar *\n     \nname\n : The name of the label\n\n\nchar *\n     \ntext\n : The text of the label\n\n\nt_color\n     \ncolor\n : The text color of the label\n\n\nint\n         \nsize\n : The size of the label\n\n\nt_bunny_position\n    \npos\n : The position of he label\n\n\nt_checkbox\n\n\nchar            *name;\nint         state;\nt_size      size;\nt_color     backcolor;\nptrfct      oncheckstatechanged;\nt_label     *label;\n\n\n\n\nchar *\n         \nname\n : The name of th checkbox\n\n\nint\n         \nstate\n : The current state of the checkbox\n\n\nt_size\n      \nsize\n : The size of the checkbox\n\n\nptrfct\n      \noncheckstatechanged\n : The function called when the \noncheckstatechanged\n event occurs\n\n\nt_label *\n      \nlabel\n : The label linked to the checkbox\n\n\nt_progressbar\n\n\nchar            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     backColor;\nt_color     barColor;\nint         value;\nint         max;\nint         min;\nt_label     attached_text;\n\n\n\n\nchar *\n         \nname\n\n\n\n\nThe name of the progressbar\n\n\n\n\nt_bunny_position\n    \npos\n\n\n\n\nThe position of the progressbar\n\n\n\n\nt_size\n      \nsize\n\n\n\n\nThe size of the progressbar\n\n\n\n\nt_color\n     \nborderColor\n\n\n\n\nThe color of the progressbar border\n\n\n\n\nint\n         \nborderSize\n\n\n\n\nThe size of the progressbar's border\n\n\n\n\nt_color\n     \nbackColor\n\n\n\n\nThe back color of the progressbar\n\n\n\n\nt_color\n     \nbarColor\n\n\n\n\nThe color of the progressbar's bar\n\n\n\n\nint\n         \nvalue\n\n\n\n\nThe current value of the progressbar\n\n\n\n\nint\n         \nmax\n\n\n\n\nThe max value of the progressbar\n\n\n\n\nint\n         \nmin\n\n\n\n\nThe minimum value of the progressbar\n\n\n\n\nt_label\n     \nattached_text\n\n\n\n\nThe text attached to the progressbar\n\n\n\n\nt_textbox\n\n\nchar            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nchar            *placeholder;\nt_color     placeholder_color;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;\nptrfct      ontextchanged;\nint         waiting_for_text;\n\n\n\n\nchar *\n         \nname\n : The name\n\n\nt_bunny_position\n    \npos\n : The position\n\n\nt_size\n      \nsize\n : The size\n\n\nt_color\n     \nborderColor\n : The border color\n\n\nint\n         \nborderSize\n : The border size\n\n\nt_color\n     \ninnerColor\n : The inner coloor\n\n\nchar *\n         \ntext\n : The predefined text\n\n\nchar *\n         \nplaceholder\n : the placeholder (Appear if no text is typed)\n\n\nt_color\n     \nplaceholder_color\n : The placeholder font color\n\n\nint\n         \nfontSize\n : The text font size\n\n\nt_color\n     \nfontColor\n : The text font color\n\n\nptrfct\n      \nonclick\n : The function called when the \nonclick\n event occurs\n\n\nptrfct\n      \nonhover\n : The function called when the \nonhover\n event occurs\n\n\nptrfct\n      \nontextchanged\n : The function called when the \nontextchanged\n event occurs\n\n\nint\n         \nwaiting_for_text\n : Set to 1 if the textbox is waiting text \ni.e.\n the textbox is selected\n\n\nt_image\n\n\nSee the \nImage macros\n\n\nchar            *name;\nint         borderSize;\nt_color     borderColor;\nchar            *src;\nt_size      size;\nt_bunny_position    pos;\nptrfct      onclick;\n\n\n\n\nchar *\n         \nname\n : The name\n\n\nint\n         \nborderSize\n : the size of the border\n\n\nt_color\n     \nborderColor\n : The color of the border\n\n\nchar *\n         \nsrc\n : The path to the image source\n\n\nt_size\n      \nsize\n : The size of the frame where the image will be displayed\n\n\nt_bunny_position\n    \npos\n : The position\n\n\nptrfct\n      \nonclick\n : The function called when the \nonclick\n event occurs\n\n\nt_tekgui\n\n\nstruct s_tekgui *child_win;\nint         child_win_nbr;\nt_button        *buttons;\nint         buttons_nbr;\nt_checkbox      *checkboxs;\nint         checkboxs_nbr;\nt_progressbar       *progressbars;\nint         progressbars_nbr;\nt_label     *labels;\nint         labels_nbr;\nt_textbox       *textboxs;\nint         textboxs_nbr;\nt_image     *images;\nint         images_nbr;\nt_bunny_ini     *config;\nt_size      size;\nt_bunny_window  *win;\nchar            *name;\nt_bunny_pixelarray  *pix;\nt_color     bgcolor;\nt_bunny_pixelarray  *font;\nt_bunny_pixelarray  **png_checkbox;\nt_callback_list callback;\ndouble      progress;\nvoid            *userdata;\n\n\n\n\nstruct s_tekgui   *\nchild_win\n : A pointer to windows child of the main window\n\n\nint\n \nchild_win_nbr\n : The number of child windows\n\n\nt_button *\nbuttons\n : A pointer to the buttons\n\n\nint\n \nbuttons_nbr\n : The number of buttons\n\n\nt_checkbox *\n \ncheckboxs\n : A pointer to the checkboxs\n\n\nint\n \ncheckboxs_nbr\n : The number of checkboxs\n\n\nt_progressbar *\n \nprogressbars\n : A pointer to the progressbars\n\n\nint\n \nprogressbars_nbr\n : The number of progressbars\n\n\nt_label *\n \nlabels\n : A pointer to the labels\n\n\nint\n \nlabels_nbr\n : The number of labels\n\n\nt_textbox *\n \ntextboxs\n : A pointer to the textboxs\n\n\nint\n \ntextboxs_nbr\n : The number of textboxs\n\n\nt_image *\n \nimages\n : A pointer to the images\n\n\nint\n \nimages_nbr\n : The number of images\n\n\nt_bunny_ini *\n \nconfig\n : The current config file\n\n\nt_size\n \nsize\n : The window original size\n\n\nt_bunny_window *\n \nwin\n : The \nt_buny_window\n component (for sharing)\n\n\nchar *\n \nname\n : The window name\n\n\nt_bunny_pixelarray *\n \npix\n : The render \npixelarray\n\n\nt_color\n \nbgcolor\n : The background color\n\n\nt_bunny_pixelarray *\n \nfont\n : The font file\n\n\nt_bunny_pixelarray **\n \npng_checkbox\n : The checkbox image ressource\n\n\nvoid *\n \nuserdata\n : The variable where the user can put his datas\n\n\nTips and tricks\n\n\nYou can define colors in several ways\n\nIf you have an \nunsigned int\n : 0xff0000\n\nBut you need a \nt_color\n, you can simply do this :\n\n\nt_color color;\nunsigned int c;\n\nc = 0xff0000;\ncolor.full = c;\n\n\n\n\nIt will convert your \nunsigned int\n to a \nt_color\n\nIn reverse you can do this too\n\n\nt_color color;\nunsigned int c;\n\ncolor.argb[0] = 255;\ncolor.argb[1] = 0;\ncolor.argb[2] = 0;\nc = color.full;", 
            "title": "Function list"
        }, 
        {
            "location": "/en/function_list/#functions", 
            "text": "t_tekgui    *tekgui_load(const char *file);  Load a configuration file  file  inside a  t_tekgui *   void        tekgui_unload(t_tekgui *tekgui);  Unload  tekgui  from the memory   void        tekgui_display(t_bunny_pixelarray   *pix,\n                           t_tekgui             *gui);  Put the graphical representation of  gui  inside  pix   void        fill_color(t_bunny_pixelarray   *pixelarray,\n                        unsigned int        color);  Fill completely  pixelarray  wiht the color  color   void            set_max_heap_size(size_t);  Set the max ram for the program   void            tekpixel(t_bunny_pixelarray *a,\n                 t_bunny_position   *p,\n                 t_color        *c);  Set the color of a pixel at the position  p , of color  c  and inside  a   t_bunny_position    new_bunny_position(int x, int y);  Create a  t_bunny_position  from  x  and  y   t_size          new_size(int w, int h);  Create a  t_size  from  width  w  and height  h   void            tekline(t_bunny_pixelarray  *pix,\n                t_bunny_position    *pos,\n                t_color         *color);  Draw a line inside  pix  from  pos[0]  to  pos[1]  of color  color   int         tekgui_putstring(t_text         text,\n                     t_bunny_pixelarray *pix,\n                     t_bunny_pixelarray *font);  Put a string from a  t_text  inside  pix  with the font  font   unsigned int        tekgetpixel(t_bunny_pixelarray  *a,\n                    t_bunny_position    *p);  return in an  unsigned int  the pixel color at  p  inside  a   t_color         new_color(int r, int g, int b, int a);  Create a  t_color  from  r ,  g ,  b  and  a  component   t_color         load_ini_color(t_bunny_ini *ini,\n                       char *field,\n                       char *name);  load a  t_color  from  ini  at  field - name   void            *tekfunction(const char *funcname);  Return a function pointer from a  char *  name   int         is_hover(t_bunny_position   *from_pos,\n                 t_bunny_position   *pos,\n                 t_size         *size);  Determine if the position  from_pos  is inside the rectangle  pos-size   int         display_button(t_bunny_pixelarray   *pix,\n                       t_button         *button,\n                       t_bunny_pixelarray   *font);  Update the graphics of  button  inside  pix  with the font  font   t_size          load_ini_size(t_bunny_ini *ini, char *scope);  load a  t_size  from a  scope  inside  ini   t_bunny_position    load_ini_position(t_bunny_ini *ini, char *scope);  Load a   t_bunny_position  from  scope  inside  ini   int         display_textbox(t_bunny_pixelarray  *pix,\n                    t_textbox       *textbox,\n                    t_bunny_pixelarray  *font);  Update the graphics of a  textbox  inside  pix  wiht the  font   void            check_box(t_tekgui *gui, t_checkbox *checkbox);  Force checking  checkbox   void            uncheck_box(t_tekgui *gui, t_checkbox *checkbox);  Force unchecking  checkbox   int         display_checkbox(t_bunny_pixelarray *pix,\n                     t_checkbox     *checkbox,\n                     t_bunny_pixelarray *font,\n                     t_bunny_pixelarray **png_checkbox);  update the graphics of  checkbox  inside  pix , with  font  and  png_checkbox  graphics   void            tekgui_show(t_tekgui        *gui);  Open a window a show the  gui   t_bunny_pixelarray  *stretch(t_bunny_pixelarray *oldpixel,\n                 int            newx,\n                 int            newy);  Stretch an an image inside  oldpixel  to be resize to  newx, newy   t_progressbar       *progressbar_get(t_tekgui *gui, char *name);  Get a progressbar by its  name   int         progressbar_setprogress(t_tekgui        *gui,\n                        t_progressbar       *progressbar,\n                        int         progress);  Set the  progressbar  progress to  progress   int         progressbar_getprogress(t_progressbar *progressbar);  get the current progress from a  progressbar   int         display_prgrsbar(t_bunny_pixelarray *pix,\n                     t_progressbar      *prgrsbar);  Force update graphic of  prgrsbar inside pix`   t_button        *button_get(t_tekgui *gui, char *name);  Get a  t_button  from its  name   int         button_settext(t_tekgui     *gui,\n                       t_button     *button,\n                       char     *text);  Set the  text  of a  button   char            *button_gettext(t_button *button);  Get the text of a  button   char            *checkbox_gettext(t_checkbox *checkbox);  Get the text of a  t_checkbox   t_checkbox      *checkbox_get(t_tekgui *gui, char *name);  Get a  t_checkbox  from its name   int         checkbox_settext(t_tekgui   *gui,\n                     t_checkbox *checkbox,\n                     char       *text);  Set the  text   of a  checkbox   t_image         *image_get(t_tekgui *gui, char *name);  Retrieve a  t_image  from a  name   char            *image_getsrc(t_image *image);  Get the image  src   int         image_setsrc(t_tekgui   *gui,\n                     t_image    *image,\n                     char   *src);  Set the  image   src   int         display_label(t_bunny_pixelarray    *pix,\n                      t_label           *label,\n                      t_bunny_pixelarray    *font);  Force update graphics of a  t_label   t_textbox       *textbox_get(t_tekgui *gui, char *name);  retrieve  t_textbox  from its  name   char            *textbox_gettext(t_textbox *textbox);  Get text of a  t_textbox   int         textbox_settext(t_tekgui    *gui,\n                    t_textbox   *textbox,\n                    char        *text);  Set the text of a  t_textbox   int         display_image(t_bunny_pixelarray    *pix,\n                      t_image           *image,\n                      int           mode);  Force update the graphic of a  t_image   char            *getfield_safe(t_bunny_ini *ini,\n                       char *scope,\n                       char *field,\n                       int index);  Get a field from a  ini  with error management", 
            "title": "Functions"
        }, 
        {
            "location": "/en/function_list/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/en/function_list/#checkbox", 
            "text": "You can check if the state of a checkbox is equal to  CHECKED   UNCHECKED", 
            "title": "Checkbox"
        }, 
        {
            "location": "/en/function_list/#image", 
            "text": "There are different size mode for images :  STRETCHMODE_FILL  : The image fille the  size  in any way  STRETCHMODE_NONE  : The image is loaded normaly. If the  size  is bigger than the image, it is sticked at the top-left. If the  size  is smaller, the image is cropped  STRETCHMODE_CENTER  : The image is loaded normaly. If the  size  is bigger than the image, it is sticked at the center. If the  size  is smaller, the image is cropped", 
            "title": "Image"
        }, 
        {
            "location": "/en/function_list/#structures", 
            "text": "", 
            "title": "Structures"
        }, 
        {
            "location": "/en/function_list/#t_size", 
            "text": "int     width;\nint     height;  width  :  integer  : the width of the size  height  :  integer  : the height of the size", 
            "title": "t_size"
        }, 
        {
            "location": "/en/function_list/#t_text", 
            "text": "char                *text;\nint                 size;\nt_bunny_position    position;\nt_color             color;\nt_bunny_pixelarray  *pix;  char *   text  : the text that will be printed  t_size   size  : the size of the component  t_bunny_position   position  : the position of the component  t_color   color  : the color of the text  t_bunny_pixel_array *   pix  : the pixelarray where the text will be dislpayed", 
            "title": "t_text"
        }, 
        {
            "location": "/en/function_list/#t_button", 
            "text": "char            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;  char *   name  : the name of the button  t_bunny_position   pos  : The position of the button  t_size   size  : The size of the button  t_color   borderColor  : The color of the border of the button  integer   borderSize  : The size of the button's border (in pixels)  t_color   innerColor  : The button's inner color  char *   text  : The text of the button  integer   fontSize  : the font size of the button's text  t_color   fontColor  : The color of the button's text  ptrfct   onclick  : The function called when the  onclick  event occurs  ptrfct   onhover  : The function called when the  onhover  event occurs", 
            "title": "t_button"
        }, 
        {
            "location": "/en/function_list/#t_label", 
            "text": "char            *name;\nchar            *text;\nt_color     color;\nint         size;\nt_bunny_position    pos;  char *       name  : The name of the label  char *       text  : The text of the label  t_color       color  : The text color of the label  int           size  : The size of the label  t_bunny_position      pos  : The position of he label", 
            "title": "t_label"
        }, 
        {
            "location": "/en/function_list/#t_checkbox", 
            "text": "char            *name;\nint         state;\nt_size      size;\nt_color     backcolor;\nptrfct      oncheckstatechanged;\nt_label     *label;  char *           name  : The name of th checkbox  int           state  : The current state of the checkbox  t_size        size  : The size of the checkbox  ptrfct        oncheckstatechanged  : The function called when the  oncheckstatechanged  event occurs  t_label *        label  : The label linked to the checkbox", 
            "title": "t_checkbox"
        }, 
        {
            "location": "/en/function_list/#t_progressbar", 
            "text": "char            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     backColor;\nt_color     barColor;\nint         value;\nint         max;\nint         min;\nt_label     attached_text;  char *           name   The name of the progressbar   t_bunny_position      pos   The position of the progressbar   t_size        size   The size of the progressbar   t_color       borderColor   The color of the progressbar border   int           borderSize   The size of the progressbar's border   t_color       backColor   The back color of the progressbar   t_color       barColor   The color of the progressbar's bar   int           value   The current value of the progressbar   int           max   The max value of the progressbar   int           min   The minimum value of the progressbar   t_label       attached_text   The text attached to the progressbar", 
            "title": "t_progressbar"
        }, 
        {
            "location": "/en/function_list/#t_textbox", 
            "text": "char            *name;\nt_bunny_position    pos;\nt_size      size;\nt_color     borderColor;\nint         borderSize;\nt_color     innerColor;\nchar            *text;\nchar            *placeholder;\nt_color     placeholder_color;\nint         fontSize;\nt_color     fontColor;\nptrfct      onclick;\nptrfct      onhover;\nptrfct      ontextchanged;\nint         waiting_for_text;  char *           name  : The name  t_bunny_position      pos  : The position  t_size        size  : The size  t_color       borderColor  : The border color  int           borderSize  : The border size  t_color       innerColor  : The inner coloor  char *           text  : The predefined text  char *           placeholder  : the placeholder (Appear if no text is typed)  t_color       placeholder_color  : The placeholder font color  int           fontSize  : The text font size  t_color       fontColor  : The text font color  ptrfct        onclick  : The function called when the  onclick  event occurs  ptrfct        onhover  : The function called when the  onhover  event occurs  ptrfct        ontextchanged  : The function called when the  ontextchanged  event occurs  int           waiting_for_text  : Set to 1 if the textbox is waiting text  i.e.  the textbox is selected", 
            "title": "t_textbox"
        }, 
        {
            "location": "/en/function_list/#t_image", 
            "text": "See the  Image macros  char            *name;\nint         borderSize;\nt_color     borderColor;\nchar            *src;\nt_size      size;\nt_bunny_position    pos;\nptrfct      onclick;  char *           name  : The name  int           borderSize  : the size of the border  t_color       borderColor  : The color of the border  char *           src  : The path to the image source  t_size        size  : The size of the frame where the image will be displayed  t_bunny_position      pos  : The position  ptrfct        onclick  : The function called when the  onclick  event occurs", 
            "title": "t_image"
        }, 
        {
            "location": "/en/function_list/#t_tekgui", 
            "text": "struct s_tekgui *child_win;\nint         child_win_nbr;\nt_button        *buttons;\nint         buttons_nbr;\nt_checkbox      *checkboxs;\nint         checkboxs_nbr;\nt_progressbar       *progressbars;\nint         progressbars_nbr;\nt_label     *labels;\nint         labels_nbr;\nt_textbox       *textboxs;\nint         textboxs_nbr;\nt_image     *images;\nint         images_nbr;\nt_bunny_ini     *config;\nt_size      size;\nt_bunny_window  *win;\nchar            *name;\nt_bunny_pixelarray  *pix;\nt_color     bgcolor;\nt_bunny_pixelarray  *font;\nt_bunny_pixelarray  **png_checkbox;\nt_callback_list callback;\ndouble      progress;\nvoid            *userdata;  struct s_tekgui   * child_win  : A pointer to windows child of the main window  int   child_win_nbr  : The number of child windows  t_button * buttons  : A pointer to the buttons  int   buttons_nbr  : The number of buttons  t_checkbox *   checkboxs  : A pointer to the checkboxs  int   checkboxs_nbr  : The number of checkboxs  t_progressbar *   progressbars  : A pointer to the progressbars  int   progressbars_nbr  : The number of progressbars  t_label *   labels  : A pointer to the labels  int   labels_nbr  : The number of labels  t_textbox *   textboxs  : A pointer to the textboxs  int   textboxs_nbr  : The number of textboxs  t_image *   images  : A pointer to the images  int   images_nbr  : The number of images  t_bunny_ini *   config  : The current config file  t_size   size  : The window original size  t_bunny_window *   win  : The  t_buny_window  component (for sharing)  char *   name  : The window name  t_bunny_pixelarray *   pix  : The render  pixelarray  t_color   bgcolor  : The background color  t_bunny_pixelarray *   font  : The font file  t_bunny_pixelarray **   png_checkbox  : The checkbox image ressource  void *   userdata  : The variable where the user can put his datas", 
            "title": "t_tekgui"
        }, 
        {
            "location": "/en/function_list/#tips-and-tricks", 
            "text": "You can define colors in several ways \nIf you have an  unsigned int  : 0xff0000 \nBut you need a  t_color , you can simply do this :  t_color color;\nunsigned int c;\n\nc = 0xff0000;\ncolor.full = c;  It will convert your  unsigned int  to a  t_color \nIn reverse you can do this too  t_color color;\nunsigned int c;\n\ncolor.argb[0] = 255;\ncolor.argb[1] = 0;\ncolor.argb[2] = 0;\nc = color.full;", 
            "title": "Tips and tricks"
        }, 
        {
            "location": "/keys/", 
            "text": "Key list\n\n\nBKS_UNKNOWN         = -1,\nBKS_A,\nBKS_B,\nBKS_C,\nBKS_D,\nBKS_E,\nBKS_F,\nBKS_G,\nBKS_H,\nBKS_I,\nBKS_J,\nBKS_K,\nBKS_L,\nBKS_M,\nBKS_N,\nBKS_O,\nBKS_P,\nBKS_Q,\nBKS_R,\nBKS_S,\nBKS_T,\nBKS_U,\nBKS_V,\nBKS_W,\nBKS_X,\nBKS_Y,\nBKS_Z,\nBKS_0,\nBKS_1,\nBKS_2,\nBKS_3,\nBKS_4,\nBKS_5,\nBKS_6,\nBKS_7,\nBKS_8,\nBKS_9,\nBKS_ESCAPE,\nBKS_LCONTROL,\nBKS_LSHIFT,\nBKS_LALT,\nBKS_LSYSTEM,\nBKS_RCONTROL,\nBKS_RSHIFT,\nBKS_RALT,\nBKS_RSYSTEM,\nBKS_MENU,\nBKS_LBRACKET,\nBKS_RBRACKET,\nBKS_SEMICOLON,\nBKS_COMMA,\nBKS_PERIOD,\nBKS_QUOTE,\nBKS_SLASH,\nBKS_BACKSLASH,\nBKS_TILDE,\nBKS_EQUAL,\nBKS_DASH,\nBKS_SPACE,\nBKS_RETURN,\nBKS_BACKSPACE,\nBKS_TAB,\nBKS_PAGEUP,\nBKS_PAGEDOWN,\nBKS_END,\nBKS_HOME,\nBKS_INSERT,\nBKS_DELETE,\nBKS_ADD,\nBKS_SUBTRACT,\nBKS_MULTIPLY,\nBKS_DIVIDE,\nBKS_LEFT,\nBKS_RIGHT,\nBKS_UP,\nBKS_DOWN,\nBKS_NUMPAD0,\nBKS_NUMPAD1,\nBKS_NUMPAD2,\nBKS_NUMPAD3,\nBKS_NUMPAD4,\nBKS_NUMPAD5,\nBKS_NUMPAD6,\nBKS_NUMPAD7,\nBKS_NUMPAD8,\nBKS_NUMPAD9,\nBKS_F1,\nBKS_F2,\nBKS_F3,\nBKS_F4,\nBKS_F5,\nBKS_F6,\nBKS_F7,\nBKS_F8,\nBKS_F9,\nBKS_F10,\nBKS_F11,\nBKS_F12,\nBKS_F13,\nBKS_F14,\nBKS_F15,\nBKS_PAUSE,\nBKS_LAST_KEY\n\n\n\n\nState list\n\n\nGO_DOWN\n is the state when the key is pressed\n\n\nGO_UP\n is the state when the key is released", 
            "title": "Keys"
        }, 
        {
            "location": "/keys/#key-list", 
            "text": "BKS_UNKNOWN         = -1,\nBKS_A,\nBKS_B,\nBKS_C,\nBKS_D,\nBKS_E,\nBKS_F,\nBKS_G,\nBKS_H,\nBKS_I,\nBKS_J,\nBKS_K,\nBKS_L,\nBKS_M,\nBKS_N,\nBKS_O,\nBKS_P,\nBKS_Q,\nBKS_R,\nBKS_S,\nBKS_T,\nBKS_U,\nBKS_V,\nBKS_W,\nBKS_X,\nBKS_Y,\nBKS_Z,\nBKS_0,\nBKS_1,\nBKS_2,\nBKS_3,\nBKS_4,\nBKS_5,\nBKS_6,\nBKS_7,\nBKS_8,\nBKS_9,\nBKS_ESCAPE,\nBKS_LCONTROL,\nBKS_LSHIFT,\nBKS_LALT,\nBKS_LSYSTEM,\nBKS_RCONTROL,\nBKS_RSHIFT,\nBKS_RALT,\nBKS_RSYSTEM,\nBKS_MENU,\nBKS_LBRACKET,\nBKS_RBRACKET,\nBKS_SEMICOLON,\nBKS_COMMA,\nBKS_PERIOD,\nBKS_QUOTE,\nBKS_SLASH,\nBKS_BACKSLASH,\nBKS_TILDE,\nBKS_EQUAL,\nBKS_DASH,\nBKS_SPACE,\nBKS_RETURN,\nBKS_BACKSPACE,\nBKS_TAB,\nBKS_PAGEUP,\nBKS_PAGEDOWN,\nBKS_END,\nBKS_HOME,\nBKS_INSERT,\nBKS_DELETE,\nBKS_ADD,\nBKS_SUBTRACT,\nBKS_MULTIPLY,\nBKS_DIVIDE,\nBKS_LEFT,\nBKS_RIGHT,\nBKS_UP,\nBKS_DOWN,\nBKS_NUMPAD0,\nBKS_NUMPAD1,\nBKS_NUMPAD2,\nBKS_NUMPAD3,\nBKS_NUMPAD4,\nBKS_NUMPAD5,\nBKS_NUMPAD6,\nBKS_NUMPAD7,\nBKS_NUMPAD8,\nBKS_NUMPAD9,\nBKS_F1,\nBKS_F2,\nBKS_F3,\nBKS_F4,\nBKS_F5,\nBKS_F6,\nBKS_F7,\nBKS_F8,\nBKS_F9,\nBKS_F10,\nBKS_F11,\nBKS_F12,\nBKS_F13,\nBKS_F14,\nBKS_F15,\nBKS_PAUSE,\nBKS_LAST_KEY", 
            "title": "Key list"
        }, 
        {
            "location": "/keys/#state-list", 
            "text": "GO_DOWN  is the state when the key is pressed  GO_UP  is the state when the key is released", 
            "title": "State list"
        }
    ]
}